/* --------------------------------------------------------------------------------
#
#	4DPlugin.c
#	source skeleton generated by 4D Plugin Wizard
#	Project : Win32API
#	author :  dcompton & dschilling
#	6/21/2001
#
# --------------------------------------------------------------------------------*/

//
//	04/16/02 Replaced Plugin API 671 with 672.  Made modifications to 
//						672 for compatibility with 4D 6.5
//
//	08/23/02 Replaced Plugin API 672 with 681.  Made modifications for 
//						compatibility with 4D 6.5 (Win32API release version 3.5)
//	09/04/02 Corrected version flag in 4DPluginAPI.c.  Added sys_IsAppLoaded for 
//						version release 3.5.1
//
//	IMPORTANT: The 4DPluginAPI.c code has been modified to be backwards compatible with pre 6.7
//	IMPORTANT		4D.  Only functions that necaessry for the Win32API plugin have been modified.
//	IMPORTANT		Other functions may require modification if used in Win32API.
//	IMPORTANT		If compatibility with pre-6.7 4D is required, DO NOT replace 4DPluginAPI.c 
//	IMPORTANT		without first comparing and copying code modifications from the modified 672. 


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#include <string.h>
#include <stdio.h>
#include <commdlg.h>
#include <commctrl.h> 
#include <rpc.h>
#include <IphlpApi.h> //req'd for sys_GetRoutes
#include <time.h> // req'd for sys_GetOCTOffset
#include <sys/timeb.h> // req'd for sys_GetOCTOffset
#include <winspool.h>
#include "PrivateTypes.h"
#include "EntryPoints.h"
// WJF 9/14/15 #43727 No longer needed
//#include "EZTWAIN.h" // REB 6/23/09 #14151 
//#include "TWAIN.h" // REB 6/23/09 #14151
#include "utilities.h" // REB 3/28/11 #25290
#include "process.h" // REB 2/25/13 #35165

char		g_methodText[255]; // holds method name to execute on tool tip action
char		intrProcStr1[MAX_PATH], intrProcStr2[MAX_PATH];
BOOL		g_bDragFull;
pLL			startOfList = NULL; // unordered linked list for restictWindow
HANDLE		hSubclassMutex;  // MJG 3/26/04
BOOL		g_FolderSelected;  // MJG 6/15/05
char		pathName[512]; // MWD 10/21/05 #9246 holds path to Win32API.4DX
LPCWSTR		KEY_DisableTaskMgr = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System";
LPCWSTR		VAL_DisableTaskMgr = "DisableTaskMgr";
LONG_PTR	windowStyle = 0; // REB 3/11/10 #23109 To hold the default window style.

struct		HOOKHANDLES
{
	HHOOK		openSaveHookHndl;
	HHOOK		printSettingsHookHndl;
	HHOOK		printHookHndl;
	HHOOK		postProcHookHndl;
	HHOOK		systemMsgHook; // used to hook window for tool tips
	HHOOK		keyboardLLHook; // REB 1/8/10 #22389 Handles low level keyboard events.
} hookHandles;

HANDLE		g_parentHndl;// dialog handle used in Open/Save functions

struct		WINDOWHANDLES
{
	HWND		fourDhWnd; // 4D main window
	HWND		prtSettingshWnd; // handle your print settings dialog
	HWND		prthWnd; // handle to print dialog
	HWND		MDIhWnd;
	HWND		hwndTT; // used for tool tips
	HWND		displayedTTOwnerhwnd; // used for tool tips
	HWND		openSaveTBhwnd; // used in Open/Save dialog
	HWND		MDIs_4DhWnd; // window to get class for all 4D windows (ProToolsSubMDIWndClass)
} windowHandles;

struct		PROCESSHANDLES
{
	WNDPROC		wpFourDOrigProc; // used for tray icon subclass
	WNDPROC		wpPrintSettingsDlgOrigProc; // used for subclassing Print Settings Dialog
	WNDPROC		wpPrintDlgOrigProc; // used for subclassing Print Dialog
	WNDPROC		wpProToolsOrigProc; // used for subclassing ALL 4D windows
} processHandles;

INT_PTR				FD_Flags; // used for open file dialog
INT_PTR				g_intrProcMsg = PS_IDLE;

struct		PRINTSETTINGS
{
	char		printerSelection[80];
	char		size[80];
	char		source[80];
	LONG_PTR		portraitLandscape;
	char		copies[10];
	BOOL		printPreview;
	BOOL		printToFile;
} printerSettings;

// various flags used to know what feature/functions are living call to call
struct		ACTIVECALLS
{
	BOOL		bPrinterCapture;
	BOOL		bTrayIcons;
	BOOL		b4DMaximize; //01/21/03
} activeCalls;

//added 01/17/03 see 4DPlugin082102.c

// REB 4/7/09 #19472
typedef struct _REG_TZI_FORMAT
{
	LONG Bias;
	LONG StandardBias;
	LONG DaylightBias;
	SYSTEMTIME StandardDate;
	SYSTEMTIME DaylightDate;
} REG_TZI_FORMAT;





extern struct		TOOLBARRESTRICT
{
	LONG_PTR		toolBarOnDeck;
	LONG_PTR		top;
	LONG_PTR		left;
	LONG_PTR		right;
	LONG_PTR		bottom;
	INT_PTR			topProcessNbr;
	INT_PTR			leftProcessNbr;
	INT_PTR			rightProcessNbr;
	INT_PTR			bottomProcessNbr;
	LONG_PTR		trackingRestriction;
	LONG_PTR		appBeingMaxed;
	LONG_PTR		appWindowState;
	RECT		origWindowRect;
	LONG_PTR		clientOffsetx;
	LONG_PTR		clientOffsety;
	char		minimizedWindows[SMLBUF][SMLBUF]; // REB 8/11/08 #16207 
	RECT		previousWindowRect; // REB 3/26/10
} toolBarRestrictions;


// REB 2/26/13 #35165 Structure to communicate with the helper thread
typedef struct	_TWAIN_CAPTURE
{
	long		returnValue; // WJF 9/14/15 #43727 Changed to long from LONG_PTR
	// HANDLE		DIBHandle; // WJF 9/10/15 #43727 No longer needed
	BOOL		done;
	char		*filePath; // WJF 9/10/15 #43727 File path to save the image to
	BOOL		showUI; // WJF 9/10/15 #43727 True to show TWAIN UI, false to hide
	BOOL		get64; // WJF 9/10/15 #43727 True to load 64-bit TWAIN drivers, false to load 32-bit
	BOOL		wiaMode; // WJF 9/21/15 #43940 True to get/acquire WIA
	BOOL		getMultiple; // WJF 9/21/15 #43940 True to acquire multiple images at once
	long		numPictures; // WJF 9/21/15 #43940 Number of pictures returned
	
} TWAIN_CAPTURE;


// MWD 10/21/05 #9246
// Use the DllMain function to get the path to the calling DLL and store it in a global for further use.
#if WIN32
#ifdef _cplusplus
extern "C" __declspec(dllexport) {
#endif
	BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
	{
		BOOL result = TRUE;
		char fullpath[512] = "";
		GetModuleFileName(hinstDLL, fullpath, sizeof (fullpath)); // Get the path to the 4DX
		strcpy((char *)pathName, (char *)fullpath);
		return result;
	}
#ifdef _cplusplus
}
#endif
#endif


void PluginMain(LONG_PTR selector, PA_PluginParameters params)
{

	HWND				hWnd, NexthWnd;
	PA_Unistring		Unistring;
	char				*pathName, *charPos;
	char			WindowName[255];
	char			szClassName[255];

	switch (selector)
	{
		// --- Win32API Commands


	case kInitPlugin:
	case kServerInitPlugin:
#ifdef _WIN64 // WJF 9/1/15 #43731/#43732 64-bit was returning a value not defined in the API
	case k64Init: 
#endif
		// get MDI & parent window on init 4/15/02
		// REB 2/20/09 #19122 Use new method to get handles.  PA_GetHWND(0) does not work in v11 like it did in previous version.
		// REB 3/24/10 It appears that PA_GetHWND(0) works again, at least in Win7, but I'm leaving this change in place.
		// REB 4/20/11 #27322 Support for the GetMainWindow and GetMDIClientWindow commands is no longer available in the new 4D API. Also PA_GetHWND seems to not work when
		//    there is no focused window in 4D.  Instead I'll use the server workaround.

		// This logic fails if there is a separate application running that returns the same value from GetClassLongPtr as PA_Get4DHInstance returns.
		/*
		h = (HINSTANCE)PA_Get4DHInstance();
		hWnd = NULL;

		w = FindWindow(NULL, NULL);

		do {
		if(!GetParent(w)){
		if(h == (HINSTANCE)GetClassLongPtr(w, GCLP_HMODULE)){
		hWnd = w;
		break;
		}
		}

		w = GetWindow(w, GW_HWNDNEXT);

		} while (w);

		windowHandles.MDIs_4DhWnd = w;

		*/

		// REB 11/2/12 #34333
		Unistring = PA_GetApplicationFullPath();
		pathName = UnistringToCString(&Unistring);
		charPos = strrchr(pathName, '\\');
		*charPos = 0;
		windowHandles.fourDhWnd = FindWindowEx(NULL, NULL, pathName, NULL);

		free(pathName); // WJF 6/25/15 #42792

		NexthWnd = GetWindow(windowHandles.fourDhWnd, GW_CHILD);
		do {
			if (IsWindow(NexthWnd)){
				GetWindowText(NexthWnd, WindowName, 255);
				GetClassName(NexthWnd, szClassName, 255);
				if (strcmp(_strlwr(szClassName), "mdiclient") == 0){
					//windowHandles.MDIs_4DhWnd =  NexthWnd; // AMS 8/12/14 #39693 This was not the correct handle to use for the MDI Client. It was causing toolbars to work incorrectly.  
					windowHandles.MDIhWnd = NexthWnd; // AMS 8/12/14 #39693 This is the correct handle for the MDI Client.
					break;
				}
				NexthWnd = GetNextWindow(NexthWnd, GW_HWNDNEXT);
			}
		} while (IsWindow(NexthWnd));




		//windowHandles.fourDhWnd = GetMainWindow();
		//windowHandles.MDIhWnd = GetMDIClientWindow();
		// REB 8/30/11 #28504 We already have this handle now.
		windowHandles.MDIs_4DhWnd = GetWindow(windowHandles.MDIhWnd, GW_CHILD); //REB 3/26/10 #22878 Get the correct child handle so toolbars work correctly. // AMS 8/12/14 #39693 Uncommented this line. This line is still needed in order for tollbars to work correctly.

		SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &g_bDragFull, 0);
		hSubclassMutex = CreateMutex(NULL, FALSE, "Win32APIMutexToProtect4DProc");  // MJG 3/26/04

		handleArray_init(); // WJF 9/1/15 #43731
	
		twainSource = NULL; // WJF 9/11/15 #43727

		break;

	case kDeinitPlugin:
		if (!PA_Is4DServer()) {
			gui_LoadBackground(params, TRUE); // true signifies closing subclassed window
			SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, g_bDragFull, NULL, 0);
			if (hookHandles.systemMsgHook != NULL) {
				UnhookWindowsHookEx(hookHandles.systemMsgHook);
			}
			clear_list(&startOfList);
			restoreOrig4DWindowProcess(); // MJG 3/26/04
		}
		CloseHandle(hSubclassMutex); // MJG 3/26/04
		// REB 1/8/10 #22389
		// REB 12/10/12 #34565
		//sys_EnableTaskManager( params );
		//gui_ShowTaskBar( params );
		//gui_ShowTitleBar( params );
		//gui_SetMDIOpaque( params );
		break;

	case 1:
		//Blk4D.fHandle = NULL;  OBSOLETE
		//Call4D (EX_GET_HWND, &Blk4D);
		//hWnd = (HWND)Blk4D.fHandle;
		hWnd = PA_GetHWND(NULL); // the current frontmost window
		if (!(IsWindow(hWnd))){
			// Always get the frontmost window in this way.
			//Unistring = PA_GetApplicationFullPath();
			//pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
			//charPos = strrchr(pathName,'\\');
			//*charPos = 0;
			//hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
			if (!(IsWindow(windowHandles.MDIs_4DhWnd))){
				Unistring = PA_GetApplicationFullPath();
				pathName = UnistringToCString(&Unistring);
				charPos = strrchr(pathName, '\\');
				*charPos = 0;
				windowHandles.fourDhWnd = FindWindowEx(NULL, NULL, pathName, NULL);

				free(pathName); // WJF 6/25/15 #42792

				NexthWnd = GetWindow(windowHandles.fourDhWnd, GW_CHILD);
				do {
					if (IsWindow(NexthWnd)){
						GetWindowText(NexthWnd, WindowName, 255);
						GetClassName(NexthWnd, szClassName, 255);
						if (strcmp(_strlwr(szClassName), "mdiclient") == 0){
							windowHandles.MDIs_4DhWnd = NexthWnd;
							break;
						}
						NexthWnd = GetNextWindow(NexthWnd, GW_HWNDNEXT);
					}
				} while (IsWindow(NexthWnd));

			}
			hWnd = windowHandles.MDIs_4DhWnd;
		}//else{
		//hWnd = PA_GetHWND(NULL); // the current frontmost window
		//}

		// while this is all we need to get frontmost window, we are probably looking for a titled window
		gui_GetWindow(params, hWnd);

		break;

	case 2:
		gui_GetWndRect(params, FALSE);
		break;

	case 3:
		gui_SetWndRect(params, FALSE);
		break;

	case 4:
		gui_ShowWindow(params, FALSE);
		break;

	case 5:
		sys_GetUserName(params);
		break;

	case 6:
		gui_SetWindowTitle(params, FALSE);
		break;

	case 7:
		sys_IsMultiByte(params);
		break;

	case 8:
		gui_DisableCloseBox(params, FALSE);
		break;

	case 9:
		gui_SetWindowLong(params, FALSE);
		break;

	case 10:
		gui_FlashWindow(params, FALSE);
		break;

	case 11:
		gui_WinHelp(params);
		break;

	case 12:
		sys_GetDefPrinter(params);
		break;

	case 13:
		sys_SetDefPrinter(params);
		break;

	case 14:
		sys_EnumPrinters(params);
		break;

	case 15:
		gui_DelMenuItem(params, FALSE);
		break;

	case 16:
		gui_GetOpenFileName(params);
		break;

	case 17:
		gui_GetSaveFileName(params);
		break;

	case 18:
		gui_LoadIcon(params, FALSE);
		break;

	case 19:
		gui_SetIcon(params, FALSE);
		break;

	case 20:
		gui_GetWindowFrom4DWin(params);
		break;

	case 21:
		sys_GetRegionSettings(params, TRUE);
		break;

	case 22:
		sys_GetTimeZone(params);
		break;

	case 23:
		sys_GetUTCOffset(params);
		break;

	case 24:
		gui_GetDisplayFontDPI(params);
		break;

	case 25:
		sys_GetRegionSettings(params, FALSE); // sys_GetOneRegionSetting -- uses same code as GetRegionSettings
		break;

	case 26:
		sys_GetPrintJob(params);
		break;

	case 27:
		sys_GetGUID(params);
		break;

	case 28:
		sys_GetRoutes(params);
		break;

	case 29:
		sys_GetNetworkInfo(params);
		break;

	case 30:
		sys_GetOSVersion(0, params); // first param is 0 if called as plugin call
		break;

	case 31:
		sys_PlayWav(params);
		break;

	case 32:
		sys_GetWindowMetrics(params);
		break;

	case 33:
		gui_LoadBackground(params, FALSE);
		break;

	case 34:
		sys_SetClientTime(params);
		break;

	case 35:
		sys_SetClientDate(params);
		break;

	case 36:
		gui_ToolTipCreate(params, FALSE);
		break;

	case 37:
		gui_ToolTipShowOnObject(params, FALSE);
		break;

	case 38:
		gui_ToolTipShowOnCoord(params);
		break;

	case 39:
		gui_ToolTipHide(params);
		break;

	case 40:
		gui_ToolTipDestroyControl(params);
		break;

	case 41:
		gui_SetTrayIcon(params);
		break;

	case 42:
		sys_FileCheck(params);
		break;

	case 43:
		sys_GetCommandLine(params);
		break;

	case 44:
		gui_RestrictWindow(params, FALSE);
		break;

	case 45:
		gui_GetWindowStyle(params, FALSE);
		break;

	case 46:
		gui_GetWindowState(params, FALSE);
		break;

	case 47:
		gui_SubClassInit(params);
		break;

	case 48:
		sys_ShellExecute(params);
		break;

	case 49:
		sys_IsAppLoaded(params);
		break;

	case 50:
		gui_SelectColor(params);
		break;

	case 51:
		gui_RespectToolBar(params);
		break;

	case 52:
		sys_IsConnectedToInternet(params);
		break;

	case 53:
		gui_GetSysColor(params);
		break;

	case 54:
		gui_SetSysColor(params);
		break;

	case 55:
		sys_GetEnv(params);
		break;

	case 56:
		sys_SetEnv(params);
		break;

	case 57:
	case 58:
	case 59:
	case 60:
		sys_GetRegKey(params);
		break;

	case 61:
		sys_GetRegType(params);
		break;

	case 62:
		sys_GetRegEnum(params);
		break;

	case 63:
		sys_GetDocumentList(params);
		break;

	case 64:
		sys_SetPluginLanguage(params);
		break;

	case 65:
		gui_SetWindowStyle(params);
		break;

	case 66:
		sys_FileExists(params);
		break;

	case 67:
		sys_DirectoryExists(params);
		break;

		// MWD 8/15/06 #10250
		// Enable USB Label Printing
	case 68:
		sys_PrintDirect2Driver(params);
		break;

	case 69:
		sys_KillProcessByName(params);
		break;

	case 70:
		sys_KillProcessByID(params);
		break;

	case 71:
		sys_EnumProcesses(params);
		break;

	case 72:
		sys_LogonUser(params);
		break;

	case 73:
		sys_GetTimeZoneList(params); // REB 4/6/09 #19472
		break;

	case 74:
		TWAIN_GetSources(params); // REB 6/23/09 #14151
		break;

	case 75:
		TWAIN_SetSource(params); // REB 6/23/09 #14151
		break;

	case 76:
		TWAIN_AcquireImage(params); // REB 6/23/09 #14151
		break;

	case 77:
		sys_IsAppFrontmost(params); // REB 8/21/09
		break;

	case 78:
		gui_MessageBox(params, FALSE); // REB 12/3/09
		break;

	case 79:
		gui_SetMDIOpaque(params); // REB 1/8/10 #22389
		break;

	case 80:
		gui_SetMDITransparent(params); // REB 1/8/10 #22389
		break;

	case 81:
		gui_HideTaskBar(params); // REB 1/8/10 #22389
		break;

	case 82:
		gui_ShowTaskBar(params); // REB 1/8/10 #22389
		break;

	case 83:
		gui_HideTitleBar(params); // REB 1/8/10 #22389
		break;

	case 84:
		gui_ShowTitleBar(params); // REB 1/8/10 #22389
		break;

	case 85:
		gui_MaximizeMDI(params); // REB 1/8/10 #22389
		break;

	case 86:
		gui_RestoreMDI(params); // REB 1/8/10 #22389
		break;

	case 87:
		gui_MinimizeMDI(params); // REB 1/8/10 #22389
		break;

	case 88:
		sys_DisableTaskManager(params); // REB 1/8/10 #22389
		break;

	case 89:
		sys_EnableTaskManager(params); // REB 1/8/10 #22389
		break;

	case 90:
	case 91:
	case 92:
	case 93:
		sys_SetRegKey(params, selector); // REB 11/17/10 #25402
		break;

	case 94:
		sys_IsAppRunningAsService(params); // REB 1/12/11 #25587
		break;

	case 95:
		sys_CompareBLOBs(params); // REB 11/9/12 TESTING
		break;

	case 96:
		sys_GetFileVersionInfo(params); // AMS 2/10/14 #36899
		break;

	case 97:
		sys_DeleteRegKey(params); // WJF 4/14/15 #27474
		break;

		/*case 98:
			sys_DeleteRegKey64(params); // WJF 4/14/15 #27474
			break;*/

	case 98:
		sys_DeleteRegValue(params); // WJF 4/14/15 #27474
		break;

	case 99: // WJF 4/20/15 #40598 Redid paramaters
		sys_SendRawPrinterData(params);  // AMS2 12/9/14 #40598
		break;

	case 100:
		textEncryption(params, FALSE); // WJF 5/6/15 #42665 // WJF 10/29/15 Win-4 sys_EncryptAES -> textEncryption
		break;

	case 101:
		textEncryption(params, TRUE); // WJF 5/6/15 #42665 // WJF 10/29/15 Win-4 sys_DecryptAES -> textEncryption
		break;

	case 102:
		gui_TakeScreenshot(params, FALSE); // WJF 7/7/15 #43138
		break;

	case 103:
		gui_LoadBackground(params, TRUE); // WJF 7/24/15 #43311
		break;

	case 104:
		sys_SetRegKey(params, selector); // WJF 8/31/15 #43731
		break;

	case 105:
		handleArray_remove(params); // WJF 9/1/15 #43731
		break;

	case 106:
		handleArray_free(params); // WJF 9/1/15 #43731
		break;

	case 107: // WJF 9/15/15 #43731
		hWnd = PA_GetHWND(NULL); // the current frontmost window
		if (!(IsWindow(hWnd))){

			if (!(IsWindow(windowHandles.MDIs_4DhWnd))){
				Unistring = PA_GetApplicationFullPath();
				pathName = UnistringToCString(&Unistring);
				charPos = strrchr(pathName, '\\');
				*charPos = 0;
				windowHandles.fourDhWnd = FindWindowEx(NULL, NULL, pathName, NULL);

				free(pathName); 

				NexthWnd = GetWindow(windowHandles.fourDhWnd, GW_CHILD);
				do {
					if (IsWindow(NexthWnd)){
						GetWindowText(NexthWnd, WindowName, 255);
						GetClassName(NexthWnd, szClassName, 255);
						if (strcmp(_strlwr(szClassName), "mdiclient") == 0){
							windowHandles.MDIs_4DhWnd = NexthWnd;
							break;
						}
						NexthWnd = GetNextWindow(NexthWnd, GW_HWNDNEXT);
					}
				} while (IsWindow(NexthWnd));

			}
			hWnd = windowHandles.MDIs_4DhWnd;
		}

		gui_GetWindowEx(params, hWnd);
		break;

	case 108:
		gui_GetWindowFrom4DWinEx(params); // WJF 9/15/15 #43731
		break;

	case 109:
		gui_SetForegroundWindow(params, FALSE); // WJF 9/16/15 #43929
		break;

		// WJF 9/16/15 #43731 Ex Function calls
	case 110:
		gui_GetWndRect(params, TRUE);
		break;

	case 111:
		gui_SetWndRect(params, TRUE);
		break;

	case 112:
		gui_ShowWindow(params, TRUE);
		break;

	case 113:
		gui_SetWindowTitle(params, TRUE);
		break;

	case 114:
		gui_DisableCloseBox(params, TRUE);
		break;

	case 115:
		gui_SetWindowLong(params, TRUE);
		break;

	case 116:
		gui_DelMenuItem(params, TRUE);
		break;

	case 117:
		gui_LoadIcon(params, TRUE);
		break;

	case 118:
		gui_SetIcon(params, TRUE);
		break;

	case 119:
		gui_MessageBox(params, TRUE);
		break;

	case 120:
		gui_TakeScreenshot(params, TRUE);
		break;

	case 121:
		gui_SetForegroundWindow(params, TRUE);
		break;

	case 122:
		gui_GetWindowStyle(params, TRUE);
		break;

	case 123:
		gui_RestrictWindow(params, TRUE);
		break;

	case 124:
		gui_GetWindowState(params, TRUE);
		break;

	case 125:
		gui_SetWindowStyle(params, TRUE);
		break;

	case 126:
		gui_ToolTipCreate(params, TRUE);
		break;

	case 127:
		gui_ToolTipShowOnObject(params, TRUE);
		break;

	case 128:
		gui_FlashWindow(params, TRUE);
		break;

		// WJF 9/16/15 #43731 End Ex function calls

	case 129:
		gui_SetFocusEx(params); // WJF 10/19/15 Win-3
		break;

	case 130:
		fileEncryption(params, FALSE); // WJF 10/28/15 Win-4
		break;

	case 131:
		fileEncryption(params, TRUE); // WJF 10/28/15 Win-4
		break;

	case 132:
		sys_HashText(params); // WJF 10/28/15 Win-4
		break;

	}

}

// ------------------------------- Win32API Commands ------------------------------



// ------------------------------------------------
// 
//  FUNCTION: sys_EnumPrinters( PA_PluginParameters params )
//
//  PURPOSE:	Find all printers that a workstation has available
//
//  COMMENTS:	Code modified from a method written by Tomas Restrepo.
//						 http://www.mvps.org/windev/ptk/enumprint.html
//						This module is also called by GetPrintJob.       
//						Gets local and remote printers
//						Returns info in a format suitable for using to set default printer
//
//	MODIFICATIONS: 04/20/02 added optional second param from 4D to 
//									select what is returned, i.e., 
//									0 = complete string based upon OpenPrinter and GetPrinter functions 
//									1 = printer names only (not suitable for using with sys_SetDefPrinter. 
//									2 = printer string built from registry entries for NT/2000/XP and 
//											from Win.ini file for 95/98/Me
//					08/11/09	Removed logic that checks for versions of Windows before 2000.
//
//	DATE:			dcc 07/03/01 
// 
void sys_EnumPrinters(PA_PluginParameters params)
{
	PA_Variable				printerArray;
	LONG_PTR					returnValue = 0, action = 0, defPrinterPosition, lSize = 0;
	DWORD					dwSizeNeeded, cByteNeeded, cByteUsed;
	DWORD					dwNumItems, dwTotalNumPrinters, dwRemoteNumItems = 0;
	DWORD					dwItem;
	LPPRINTER_INFO_1		lpInfo1 = NULL;
	LPPRINTER_INFO_2		lpInfo2 = NULL;
	char					printer_driver_port[255];
	char					printerName[255];
	HANDLE					hPrinter;
	PRINTER_DEFAULTS		ptrDef;
	BOOL					bPrinterSuccess, bNamesOnly = FALSE;

	printerArray = PA_GetVariableParameter(params, 1);
	PA_ResizeArray(&printerArray, 0); //09/21/01

	action = PA_GetLongParameter(params, 2);
	switch (action)
	{
	case EP_NAMES_ONLY:
		bNamesOnly = TRUE;
		break;

	case EP_USE_OPEN:
		break;

	case EP_USE_REGISTRY:
		defPrinterPosition = enumPrintersUsingRegistry(&printerArray);

		PA_SetVariableParameter(params, 1, printerArray, 0);
		PA_ReturnLong(params, defPrinterPosition);
		return;
	}

	// Get buffer size for local printers  PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS
	// Combining the two calls to EnumPrinters into a single call.
	EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 1, NULL, 0, &dwSizeNeeded, &dwNumItems);

	// allocate memory
	lpInfo1 = (LPPRINTER_INFO_1)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSizeNeeded);
	if (lpInfo1 == NULL)
	{
		returnValue = 0;
		return;
	}

	if (EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 1, (LPBYTE)lpInfo1, dwSizeNeeded, &dwSizeNeeded, &dwNumItems) == 0)	{
		// free memory
		HeapFree(GetProcessHeap(), 0, lpInfo1);
		returnValue = 0;
		PA_ReturnLong(params, returnValue);
		return;
	}

	PA_ResizeArray(&printerArray, dwNumItems);

	//localPrinters = PA_CreateVariable( eVK_ArrayString, 255);
	//PA_ResizeArray (&localPrinters, dwNumItems);
	for (dwItem = 0; dwItem < dwNumItems; dwItem++)
	{
		strcpy(printerName, lpInfo1[dwItem].pName);
		printerName[strlen(printerName)] = '\0';
		PA_SetTextInArray(printerArray, dwItem + 1, printerName, strlen(printerName));
	}
	// free memory
	HeapFree(GetProcessHeap(), 0, lpInfo1);
	dwTotalNumPrinters = dwNumItems;
	//dwLocalNumItems = dwNumItems;

	/*
	// Get buffer size for remote printers
	EnumPrinters ( PRINTER_ENUM_CONNECTIONS, NULL, 1, NULL, 0, &dwSizeNeeded, &dwNumItems );

	// allocate memory
	lpInfo1 = (LPPRINTER_INFO_1)HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY, dwSizeNeeded );
	if ( lpInfo1 == NULL )
	{
	returnValue = 0;
	return;
	}

	if ( EnumPrinters ( PRINTER_ENUM_CONNECTIONS,		// what to enumerate
	NULL,			// printer name (NULL for all)
	1,				// level
	(LPBYTE)lpInfo1,		// buffer
	dwSizeNeeded,		// size of buffer
	&dwSizeNeeded,		// returns size
	&dwNumItems			// return num. items
	) == 0 )	{
	// free memory
	HeapFree ( GetProcessHeap (), 0, lpInfo1 );
	returnValue = 0;
	PA_ReturnLong( params, returnValue );
	return;
	}

	dwRemoteNumItems = dwNumItems;
	if (dwRemoteNumItems) {
	remotePrinters = PA_CreateVariable(eVK_ArrayString, 255);
	PA_ResizeArray (&remotePrinters, dwRemoteNumItems);
	for ( dwItem = 0; dwItem < dwRemoteNumItems; dwItem++ )
	{
	strcpy(printerName, lpInfo1[dwItem].pName);
	printerName[strlen(printerName)] = '\0';
	PA_SetStringInArray (remotePrinters, dwItem + 1, printerName);
	}
	// free memory
	HeapFree ( GetProcessHeap (), 0, lpInfo1 );
	dwTotalNumPrinters += dwRemoteNumItems;
	}
	*/
	//PA_ResizeArray (&printerArray, dwTotalNumPrinters); 
	//sprintf(debugStr,"Number of elements: %d",PA_GetArrayNbElements (printerArray));
	//MessageBox(NULL,debugStr,"Debugging",MB_OK);

	// get complete info on each printer	

	ptrDef.pDatatype = NULL;
	ptrDef.pDevMode = NULL;
	ptrDef.DesiredAccess = PRINTER_ACCESS_USE;
	/*
	if (dwLocalNumItems ==0) { // 09/19/01
	ptrPA_Var = &remotePrinters;
	bRemoteOnly = TRUE;
	} else {
	ptrPA_Var = &localPrinters;
	bRemoteOnly = FALSE;
	}
	*/
	//loopOffset = 0;

	for (dwItem = 0; dwItem < dwTotalNumPrinters; dwItem++)
	{
		lSize = PA_GetTextInArray(printerArray, dwItem + 1, printerName);
		printerName[lSize] = '\0';
		strcpy(printer_driver_port, "");

		bPrinterSuccess = OpenPrinter(printerName, &hPrinter, NULL); //&ptrDef );

		if (bPrinterSuccess){
			if (!bNamesOnly) {
				// Get the buffer size needed 
				if (!GetPrinter(hPrinter, 2, NULL, 0, &cByteNeeded))
				{
					if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
						returnValue = 0;
						bPrinterSuccess = ClosePrinter(hPrinter);
						return;
					}
				}

				lpInfo2 = (PRINTER_INFO_2 *)malloc(cByteNeeded);
				if (!(lpInfo2)) {
					// failure to allocate memory 
					returnValue = 0;
					bPrinterSuccess = ClosePrinter(hPrinter);
					return;
				}

				// get the printer info 
				if (!GetPrinter(hPrinter, 2, (LPSTR)lpInfo2, cByteNeeded, &cByteUsed))
				{
					// failure to access the printer 
					free(lpInfo2);
					lpInfo2 = NULL;
					returnValue = 0;
					bPrinterSuccess = ClosePrinter(hPrinter);
					return;
				}

				strcpy(printer_driver_port, lpInfo2[0].pPrinterName);
				strcat(printer_driver_port, ",");
				strcat(printer_driver_port, lpInfo2[0].pDriverName);
				strcat(printer_driver_port, ",");
				strcat(printer_driver_port, lpInfo2[0].pPortName);
			}
			else {
				strcpy(printer_driver_port, printerName);
			}

			bPrinterSuccess = ClosePrinter(hPrinter); // REB 10/29/09 #21643 This was not getting closed.

		}
		else {
			strcpy(printer_driver_port, printerName); // chg made to populate array with name if add'l info can't be retrieved
			if (!bNamesOnly) {
				strcat(printer_driver_port, ": Could Not Open");
			}
		}

		PA_SetTextInArray(printerArray, dwItem + 1, printer_driver_port, strlen(printer_driver_port));
		/*
		if ((dwRemoteNumItems > 0) && (dwItem == (dwLocalNumItems - 1)) && (!bRemoteOnly)) {
		PA_ClearVariable(&localPrinters);
		ptrPA_Var = &remotePrinters;
		loopOffset = (LONG_PTR)dwLocalNumItems * -1; // offset so new array will start at beginning
		}
		*/
		free(lpInfo2);
		lpInfo2 = NULL;
	} //(i = 0, i < dwTotalNumPrinters, i++)

	//free memory
	HeapFree(GetProcessHeap(), 0, lpInfo2);
	/*
	if (dwTotalNumPrinters > dwLocalNumItems) {
	PA_ClearVariable(ptrPA_Var);
	}
	*/
	returnValue = dwTotalNumPrinters;

	PA_SetVariableParameter(params, 1, printerArray, 0);

	PA_ReturnLong(params, returnValue);
}


// ------------------------------------------------
// 
//  FUNCTION: sys_GetPrintJob( PA_PluginParameters params)
//
//  PURPOSE:	Primarily to get what printer was selected for printing
//
//  COMMENTS:	
//	IMPORTANT	NOTE: This an gui_SetTrayIcon use the same subclassed window procedure.
//									You cannot arbitrarily delete the function newProc
//									without breaking tray icons.
//        
//	DATE:			dcc 10/23/01 
//
//	MODIFICATIONS: Rewritten 10/23/01 to improve reliability.  Previous use
//						of spooler had several inadequacies depending on 
//						local, network printers, or print servers.
//						04/15/02 fixed problem when called from dialog box code rather than a form window 
//						11/25/02 fixed problem when Print dialog cancelled and then function called a second time (3.5.3)
void sys_GetPrintJob(PA_PluginParameters params)
{

	LONG_PTR							ret, length;
	LONG_PTR							returnValue = 0, count = 0;
	HANDLE								prntHndle;
	PA_Variable				        	printer;
	char								windowTitle[] = "", printerName[255], executeCommand[255];
	char								*pComma;
	char								returnString[20];
	LONG_PTR							printerName_len = 255, execCommand_len = 255;
	PA_Unistring						Unistring;
	DWORD								bytesRequired;
	LPDEVMODE							pDevMode;

	activeCalls.bPrinterCapture = TRUE;

	hookHandles.printSettingsHookHndl = NULL;
	hookHandles.printHookHndl = NULL;
	processHandles.wpPrintDlgOrigProc = NULL; // 08/08/02
	processHandles.wpPrintSettingsDlgOrigProc = NULL; // 08/08/02

	execCommand_len = PA_GetTextParameter(params, 2, executeCommand);
	executeCommand[execCommand_len] = '\0';
	if (execCommand_len == 0) { // the default is Print Settings
		strcpy(executeCommand, "Print Settings");
		execCommand_len = strlen(executeCommand);
	}

	//if ((activeCalls.bTrayIcons == FALSE) && (processHandles.wpFourDOrigProc == NULL)) { // same subclassed procedure used for trayIcons
	//	processHandles.wpFourDOrigProc = (WNDPROC) SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) newProc);	
	//}

	subclass4DWindowProcess(); // MJG 3/26/04 Replaced code above with function call.

	g_intrProcMsg = PS_SEARCH;

	// REB 4/20/11 #27322 Conver the C string to a Unistring
	Unistring = CStringToUnistring(&executeCommand);
	PA_ExecuteMethod(&Unistring);

	PA_DisposeUnistring(&Unistring); // WJF 6/25/15 #42792

	//PA_ExecuteMethod(executeCommand, execCommand_len);

	printer = PA_GetVariableParameter(params, 1);

	if (strlen(printerSettings.printerSelection) == 0) {
		PA_ResizeArray(&printer, 10); // WJF 4/7/15 #41184 Changed from 1 -> 10
		ret = GetProfileString("windows", "device", ",,,", printerName, printerName_len);
		pComma = strstr(printerName, ",");
		printerName[pComma - printerName] = '\0';
		strcpy(printerSettings.printerSelection, printerName);
		PA_SetTextInArray(printer, 1, printerSettings.printerSelection,
			strlen(printerSettings.printerSelection));
		returnValue = 1;

        // WJF 8/11/15 #43416 Reverted changes as crashes were occurring for certain users
		/*	// WJF 4/7/15 # 41184 Fill other members with info from the DevMode and PRINTER_INFO_2 structs
		if (OpenPrinter(&printerSettings.printerSelection, &prntHndle, NULL) == TRUE) { // Get the printer handle
			bytesRequired = DocumentProperties(NULL, prntHndle, &printerSettings.printerSelection, NULL, NULL, 0); // Get size required for DevMode struct
			pDevMode = (LPDEVMODE)malloc(bytesRequired);
			DocumentProperties(NULL, prntHndle, &printerSettings.printerSelection, pDevMode, NULL, DM_OUT_BUFFER); // Get DevMode struct
			PA_SetTextInArray(printer, 2, pDevMode->dmFormName, strlen(pDevMode->dmFormName)); // Store paper size (Letter, A4, etc)
			// Store the orientation
			if (pDevMode->dmOrientation = DMORIENT_PORTRAIT){
				PA_SetTextInArray(printer, 5, "Portrait", strlen("Portrait"));
			}
			else {
				PA_SetTextInArray(printer, 5, "Landscape", strlen("Landscape"));
			}

			GetPrinter(prntHndle, 2, 0, 0, &size); // Determine size required for printerInfo 
			pPrinterInfo = (PRINTER_INFO_2*)malloc(size);
			GetPrinter(prntHndle, 2, (LPBYTE)pPrinterInfo, size, &size); // Get printerInfo (printerport)
			size = DeviceCapabilities(&printerSettings.printerSelection, pPrinterInfo->pPortName, DC_BINNAMES, bins, NULL); // Get all tray names
			size = DeviceCapabilities(&printerSettings.printerSelection, pPrinterInfo->pPortName, DC_BINS, binNums, NULL); // Get all tray numbers
			for (int i = 0; i<size; i++) {
				if (binNums[i] == pDevMode->dmDefaultSource){
					index = i; // Find the index of the default tray since there is no way to determine selected tray
					i = size + 1;
				}
			}

			PA_SetTextInArray(printer, 3, bins[index],
				strlen(bins[index])); // Set to default bin

			// Cleanup
			free(pDevMode);
			free(pPrinterInfo);
			ClosePrinter(prntHndle);
		}
		else {
			PA_SetTextInArray(printer, 2, emptyString,
				strlen(emptyString));
			PA_SetTextInArray(printer, 3, emptyString,
				strlen(emptyString));
			PA_SetTextInArray(printer, 5, emptyString,
				strlen(emptyString));
		}
		PA_SetTextInArray(printer, 4, "1", strlen("1"));  // Assume 1 copy
		PA_SetTextInArray(printer, 6, emptyString, strlen(emptyString));
		PA_SetTextInArray(printer, 7, emptyString, strlen(emptyString));
		returnValue = 1; */
	}
	else {

		PA_ResizeArray(&printer, 10);

		PA_SetTextInArray(printer, 1, printerSettings.printerSelection,
			strlen(printerSettings.printerSelection));
		// WJF 4/6/15 #40697 If printerSettings.size is empty, we need to find the information another way (Happens when passed "PRINT SETTINGS(2)"
		if (strcmp(printerSettings.size, "") == 0) {
			if (OpenPrinter(&printerSettings.printerSelection, &prntHndle, NULL) == TRUE) { // Get the printer handle
				bytesRequired = DocumentProperties(NULL, prntHndle, &printerSettings.printerSelection, NULL, NULL, 0); // Get size required for DevMode struct
				pDevMode = (LPDEVMODE)malloc(bytesRequired);
				DocumentProperties(NULL, prntHndle, &printerSettings.printerSelection, pDevMode, NULL, DM_OUT_BUFFER); // Get DevMode struct
				PA_SetTextInArray(printer, 2, pDevMode->dmFormName, strlen(pDevMode->dmFormName)); // Store paper size (Letter, A4, etc)

				// Cleanup
				free(pDevMode);
				ClosePrinter(prntHndle);
			}
		} // End WJF 4/6/15 #40697 Changes
		else {
			PA_SetTextInArray(printer, 2, printerSettings.size,
				strlen(printerSettings.size));
		}
		PA_SetTextInArray(printer, 3, printerSettings.source,
			strlen(printerSettings.source));

		PA_SetTextInArray(printer, 4, printerSettings.copies,
			strlen(printerSettings.copies));
		if (printerSettings.portraitLandscape == PS_PORTRAIT) {
			strcpy(returnString, "Portrait");
		}
		else {
			strcpy(returnString, "Landscape");
		}
		PA_SetTextInArray(printer, 5, returnString,
			strlen(returnString));

		if (printerSettings.printToFile == TRUE) {
			strcpy(returnString, "Printed To File");
		}
		else {
			strcpy(returnString, "");
		}
		PA_SetTextInArray(printer, 6, returnString,
			strlen(returnString));

		if (printerSettings.printPreview == TRUE) {
			strcpy(returnString, "Print Preview");
		}
		else {
			strcpy(returnString, "");
		}
		PA_SetTextInArray(printer, 7, returnString, strlen(returnString));

		returnValue = strlen(printerSettings.printerSelection);
	}

	// restoreOrig4DWindowProcess(); // 01//21/03  // MJG 3/26/04 The 4D window will remain subclassed until the plug-in is unloaded.
	//if (activeCalls.bTrayIcons == FALSE) { // 11/26/02 moved this below if statement
	//SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) processHandles.wpFourDOrigProc);
	//processHandles.wpFourDOrigProc = NULL;
	//}
	if (hookHandles.printSettingsHookHndl != NULL) {
		UnhookWindowsHookEx(hookHandles.printSettingsHookHndl);
		hookHandles.printSettingsHookHndl = NULL; // 08/08/02
	}
	if (hookHandles.printHookHndl != NULL) {
		UnhookWindowsHookEx(hookHandles.printHookHndl);
		hookHandles.printHookHndl = NULL; // 08/08/02
	}

	windowHandles.prthWnd = 0;
	windowHandles.prtSettingshWnd = NULL;
	processHandles.wpPrintDlgOrigProc = NULL; // 08/08/02
	processHandles.wpPrintSettingsDlgOrigProc = NULL; // 08/08/02
	g_intrProcMsg = PS_IDLE;
	activeCalls.bPrinterCapture = FALSE;

	strcpy(printerSettings.printerSelection, "");
	PA_SetVariableParameter(params, 1, printer, 0);
	PA_ReturnLong(params, returnValue);

}


// 
//  FUNCTION: sys_GetNetworkInfo( PA_PluginParameters params )
//
//  PURPOSE:	Returns network info 
//
//  COMMENTS:	Only availabel in Windows 98 and Win2K and later
//						NOT NT 3.51 or NT 4
//
//	DATE:			dcc 08/09/01 
//
//  MODIFICATIONS:  04/10/02 made function call into pointer to
//						avoid problems with Win95/NT that may not have IphlpAPI.dll installed.
//						4D cannot resolve this when a direct reference and dll is missing
// 
void	sys_GetNetworkInfo(PA_PluginParameters params)
{
	DWORD					dwFuncReturn;
	LONG_PTR					returnValue = 0;
	char					infoString[255];
	LONG_PTR					infoString_len = strlen(infoString);
	FIXED_INFO		*fixedInfo;
	IP_ADDR_STRING	*pIPAddr;
	ULONG					ulOutBufLen;
	LPFNDLLFUNC2	lpfnDllFunc2;
	HINSTANCE			hDLL;


	hDLL = LoadLibrary("IphlpAPI.dll");

	if (hDLL != NULL) {
		lpfnDllFunc2 = (LPFNDLLFUNC2)GetProcAddress(hDLL, "GetNetworkParams");

		if (lpfnDllFunc2) {
			infoString_len = PA_GetTextParameter(params, 1, infoString);
			infoString[infoString_len] = '\0';  // Explicitly set the length

			fixedInfo = (FIXED_INFO *)GlobalAlloc(GPTR, sizeof(FIXED_INFO));
			ulOutBufLen = sizeof(FIXED_INFO);

			if (ERROR_BUFFER_OVERFLOW == lpfnDllFunc2(fixedInfo, &ulOutBufLen)) {
				GlobalFree(fixedInfo);
				fixedInfo = GlobalAlloc(GPTR, ulOutBufLen);
			}

			if (dwFuncReturn = lpfnDllFunc2(fixedInfo, &ulOutBufLen)) {
				returnValue = 0;
				PA_ReturnLong(params, returnValue);
				return;
			}
			else {
				returnValue = 1;
				strcpy(infoString, fixedInfo->HostName);
				strcat(infoString, ",");
				strcat(infoString, fixedInfo->DomainName);
				strcat(infoString, ",");
				switch ((UINT)fixedInfo->NodeType)
				{
				case BROADCAST_NODETYPE:
					strcat(infoString, "Broadcast");
					break;
				case PEER_TO_PEER_NODETYPE:
					strcat(infoString, "Peer-to-peer");
					break;
				case MIXED_NODETYPE:
					strcat(infoString, "Mixed");
					break;
				case HYBRID_NODETYPE:
					strcat(infoString, "Hybid");
				}
				strcat(infoString, ",");
				switch (fixedInfo->EnableDns)
				{
				case 0:
					strcat(infoString, "DNS No");
					break;
				default:
					strcat(infoString, "DNS Enabled");
				}

				strcat(infoString, ",");
				switch (fixedInfo->EnableRouting)
				{
				case 0:
					strcat(infoString, "Routing No");
					break;
				default:
					strcat(infoString, "Routing Enabled");
				}

				strcat(infoString, ",");
				switch (fixedInfo->EnableProxy)
				{
				case 0:
					strcat(infoString, "Proxy No");
					break;
				default:
					strcat(infoString, "Proxy Enabled");
				}
				if (strlen(fixedInfo->DnsServerList.IpAddress.String) > 0) {
					strcat(infoString, ",");
					strcat(infoString, fixedInfo->DnsServerList.IpAddress.String);
					pIPAddr = fixedInfo->DnsServerList.Next;
					while (pIPAddr) {
						strcat(infoString, ",");
						strcat(infoString, pIPAddr->IpAddress.String);
						pIPAddr = pIPAddr->Next;
					}
				}
			} //(dwFuncReturn = lpfnDllFunc2(fixedInfo, &ulOutBufLen))

			GlobalFree(fixedInfo);
			PA_SetTextParameter(params, 1, infoString, strlen(infoString));
		} // (lpfnDllFunc2)
		FreeLibrary(hDLL);
	} //(hDLL != NULL)
	PA_ReturnLong(params, returnValue);

}

// 
//  FUNCTION: sys_GetRoutes( PA_PluginParameters params )
//
//  PURPOSE:	Return IP Route Info 
//
//  COMMENTS:	
//						
//	DATE:			dcc 08/08/01 
// 
//  MODIFICATIONS:  04/10/02 made function call into pointer to
//						avoid problems with Win95/NT that may not have IphlpAPI.dll installed.
//						4D cannot resolve this when a direct reference and dll is missing
//

void	sys_GetRoutes(PA_PluginParameters params)
{
	DWORD					dwFuncReturn;
	LONG_PTR					returnValue = 0, i, tableEntries;
	PA_Variable		table;
	char					routeString[255], numToString[25];
	LONG_PTR					routeString_Len = strlen(routeString);
	ULONG					buffer_len = 0;
	MIB_IPFORWARDTABLE		rtTable;
	PMIB_IPFORWARDTABLE		pTable = &rtTable;
	MIB_IPFORWARDROW			ipRow;
	PMIB_IPFORWARDROW			pRow = &ipRow;
	BOOL					bOrder = FALSE;
	PULONG				pSize = &buffer_len;
	LPFNDLLFUNC3	lpfnDllFunc3;
	HINSTANCE			hDLL;


	hDLL = LoadLibrary("IphlpAPI.dll");

	if (hDLL != NULL) {
		lpfnDllFunc3 = (LPFNDLLFUNC3)GetProcAddress(hDLL, "GetIpForwardTable");

		if (lpfnDllFunc3) {
			table = PA_GetVariableParameter(params, 1);

			dwFuncReturn = lpfnDllFunc3(pTable, pSize, bOrder);

			// allocate memory
			pTable = (PMIB_IPFORWARDTABLE)malloc(*pSize);
			if (pTable == NULL)
			{
				returnValue = 0;
				PA_ReturnLong(params, returnValue);
				return;
			}

			dwFuncReturn = lpfnDllFunc3(pTable, pSize, bOrder);
			if (dwFuncReturn != NO_ERROR) {
				// free memory
				free(pTable);
				returnValue = 0;
				PA_ReturnLong(params, returnValue);
				return;
			}

			tableEntries = (LONG_PTR)pTable->dwNumEntries;

			returnValue = tableEntries;
			PA_ResizeArray(&table, tableEntries);

			strcpy(routeString, "");
			for (i = 0; i < tableEntries; i++)
			{
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardDest);
				strcat(routeString, ",");
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardMask);
				strcat(routeString, ",");
				FormatIP(routeString, (LPARAM)pTable->table[i].dwForwardNextHop);
				strcat(routeString, ",");

				switch ((INT_PTR)pTable->table[i].dwForwardType)
				{
				case 1:
					strcat(routeString, "Not specified");
					break;
				case 2:
					strcat(routeString, "Logically deleted");
					break;
				case 3:
					strcat(routeString, "Local - next hop final");
					break;
				case 4:
					strcat(routeString, "Remote");
				}
				strcat(routeString, ",");
				_ultoa(pTable->table[i].dwForwardAge, numToString, 10);
				strcat(routeString, numToString);

				PA_SetTextInArray(table, i + 1, routeString, strlen(routeString));
				strcpy(routeString, "");
			}

			// free memory
			free(pTable);

			PA_SetVariableParameter(params, 1, table, 0);
		} //(lpfnDllFunc3)
		FreeLibrary(hDLL);
	} //(hDLL != NULL)
	PA_ReturnLong(params, returnValue);

}


// 
//  FUNCTION: sys_GetGUID( PA_PluginParameters params )
//
//  PURPOSE:	Gets a UUID in string format
//
//  COMMENTS:	Second string parameter contains text on UUID qualifier.
//						 May be OK, Local Only, Error
//
//	DATE:			dcc 07/30/01 
// 
void sys_GetGUID(PA_PluginParameters params)
{
	UUID				uGuid;
	RPC_STATUS			rpc_status;
	PUCHAR				cGuid;
	char				guidString[MAXBUF];
	LONG_PTR				guidString_len, guidStatus_len, returnValue;
	char				guidStatus[MAXBUF];

	guidString_len = PA_GetTextParameter(params, 1, guidString);
	guidString[guidString_len] = '\0';  // Explicitly set the length
	guidStatus_len = PA_GetTextParameter(params, 2, guidStatus);
	guidStatus[guidStatus_len] = '\0';

	returnValue = 1; //unless not OK or local
	rpc_status = UuidCreate(&uGuid);
	switch (rpc_status)
	{
	case RPC_S_OK:
		strcpy(guidStatus, "OK");
		break;

	case RPC_S_UUID_LOCAL_ONLY:
		strcpy(guidStatus, "Local Only");
		break;

	case RPC_S_UUID_NO_ADDRESS:
		strcpy(guidStatus, "Cannot get Ethernet hardware address");
		returnValue = 0;
		break;

	default:
		strcpy(guidStatus, "Unknown status");
		returnValue = 0;
	}

	rpc_status = UuidToString(&uGuid, &cGuid);
	strncpy(guidString, cGuid, MAXBUF);
	RpcStringFree(&cGuid);

	guidString_len = strlen(guidString);
	guidStatus_len = strlen(guidStatus);

	PA_SetTextParameter(params, 1, guidString, guidString_len);
	PA_SetTextParameter(params, 2, guidStatus, guidStatus_len);


	PA_ReturnLong(params, returnValue);
}


// ------------------------------------------------
// 
//  FUNCTION: gui_GetWindow( PA_PluginParameters params, HWND hWnd )
//
//  PURPOSE:	Obtain Windows window handle for window with specific title
//
//  COMMENTS:	Modified 08/17/01 dcc:  Replaced all except param refs with call
//						to getWindowHandle -- an internal function that returns hndl
//						Allows use for function gui_GetWindowProcess(windowTitle)
//	DATE:
//
//	MODIFICATIONS: Added a check for window title="*".  This retreives
//									frontmost window (active window)

void gui_GetWindow(PA_PluginParameters params, HWND hWnd)
{
	LONG_PTR			windowTitle_len;
	char				*windowTitle;
	long				returnValue = 0;
	LONG_PTR			windowHandle = 0;

	//windowTitle_len = PA_GetTextParameter( params, 1, windowTitle );
	//windowTitle[windowTitle_len] = '\0';  // Explicitly set the length

	windowTitle_len = PA_GetTextParameter(params, 1, NULL) + 1;
	windowTitle = malloc(windowTitle_len * sizeof(char));
	memset(windowTitle, 0, (windowTitle_len * sizeof(char)));
	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';

	if (strcmp(windowTitle, "*") == 0) { // return the frontmost window
		windowHandle = (LONG_PTR)hWnd;

	}
	else {
		if ((strlen(windowTitle) == 0) && (windowHandles.MDIs_4DhWnd != NULL)) {
			windowHandle = (LONG_PTR)windowHandles.fourDhWnd;
		}
		else if ((strcmp(_strlwr(windowTitle), "mdi") == 0) && (windowHandles.MDIhWnd != NULL)) {
			windowHandle = (LONG_PTR)windowHandles.MDIhWnd;
		}
		else {
			windowHandle = (LONG_PTR)getWindowHandle(windowTitle, hWnd);
		}
		if (!returnValue) {
			returnValue = -3;
		}
	}

	if (windowHandle){
		returnValue = (long)windowHandle;
	}

	free(windowTitle);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetWndRect( PA_PluginParameters params )
//

void gui_GetWndRect(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR x;
	LONG_PTR y;
	LONG_PTR w;
	LONG_PTR h;
	LONG_PTR returnValue;
	LONG_PTR mode;                            // MWD 1/12/07 #12852
	HWND WindowhWnd;
	HMONITOR hMon4D;
	MONITORINFO monitorInfo;
	RECT wRect;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array
	x = PA_GetLongParameter(params, 2);
	y = PA_GetLongParameter(params, 3);
	w = PA_GetLongParameter(params, 4);
	h = PA_GetLongParameter(params, 5);
	mode = PA_GetLongParameter(params, 6);

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {

		// Allowing a return to the original functionality
		// As the new functionality broke at least one developer's code
		if (mode == 1) {
			// Old functionality
			// Get the coordinates relative the actual virtual desktop
			if (GetWindowRect(WindowhWnd, &wRect)) {
				x = wRect.left;
				y = wRect.top;
				w = wRect.right - wRect.left;
				h = wRect.bottom - wRect.top;
				returnValue = 1;
			}
			else {
				returnValue = 0;
			}
		}
		else {
			// New functionality
			// Get the coordinates within the actual monitor that it's in
			hMon4D = MonitorFromWindow(WindowhWnd, MONITOR_DEFAULTTONEAREST);
			monitorInfo.cbSize = sizeof(MONITORINFO);
			if (GetMonitorInfo(hMon4D, &monitorInfo)) {
				if (GetWindowRect(WindowhWnd, &wRect)) {
					x = wRect.left - monitorInfo.rcMonitor.left;
					y = wRect.top - monitorInfo.rcMonitor.top;
					w = wRect.right - wRect.left;
					h = wRect.bottom - wRect.top;
					returnValue = 1;
				}
				else {
					returnValue = 0;
				}
				returnValue = 1;
			}
			else {
				returnValue = (LONG_PTR)GetLastError();
			} // end if
		} // end if
	}
	else {
		returnValue = 0;
	}

	PA_SetLongParameter(params, 2, x);
	PA_SetLongParameter(params, 3, y);
	PA_SetLongParameter(params, 4, w);
	PA_SetLongParameter(params, 5, h);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetWndRect( PA_PluginParameters params )
//

void gui_SetWndRect(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR x;
	LONG_PTR y;
	LONG_PTR w;
	LONG_PTR h;
	LONG_PTR returnValue, tbHeight, tbWidth, respectTB = 0;
	HWND WindowhWnd, hWndTaskBar;
	RECT taskBarCoords;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array
	x = PA_GetLongParameter(params, 2);
	y = PA_GetLongParameter(params, 3);
	w = PA_GetLongParameter(params, 4);
	h = PA_GetLongParameter(params, 5);
	respectTB = PA_GetLongParameter(params, 6);

	// REB 11/10/11 #28503 Prevent them from making the window so large that it
	// hides the task bar.  I'm hesitant to change this because people may rely on 
	// this command to work as is.
	if (respectTB > 0){
		hWndTaskBar = FindWindow("Shell_TrayWnd", NULL); // Get a handle to the taskbar.
		if (GetWindowRect(hWndTaskBar, &taskBarCoords)){
			// We're going to assume that if height < width the taskbar is at the top or bottom.
			tbHeight = (taskBarCoords.bottom - taskBarCoords.top);
			tbWidth = (taskBarCoords.right - taskBarCoords.left);

			// Adjust the specified window size to prevent it from covering the taskbar.
			if ((taskBarCoords.top == 0)&(taskBarCoords.left == 0)){
				if (tbHeight < tbWidth){ // Top
					if (y < taskBarCoords.bottom)
						y = taskBarCoords.bottom;
				}
				else{ // Left
					if (x < taskBarCoords.right)
						x = taskBarCoords.right;
				}
			}
			else if (taskBarCoords.top == 0){ // Right
				if ((x + w) > taskBarCoords.left)
					w = taskBarCoords.left - x;

			}
			else { // Bottom
				if ((y + h) > taskBarCoords.top)
					h = taskBarCoords.top - y;
			}
		}
	}

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		if (SetWindowPos(WindowhWnd, HWND_TOP, x, y, w, h,
			SWP_ASYNCWINDOWPOS | SWP_NOACTIVATE | SWP_NOZORDER)) {
			returnValue = 1;
		}
		else {
			returnValue = 0;
		}
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_ShowWindow( PA_PluginParameters params )
//

void gui_ShowWindow(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR showState;
	LONG_PTR returnValue;
	HWND WindowhWnd;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array
	showState = PA_GetLongParameter(params, 2);

	if (isEx){ // WJF 9/16/15 #43731 
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		// REB 2/26/09 #16207 Handle this slightly differently if we are using a toolbar.
		if (toolBarRestrictions.toolBarOnDeck == 1){
			switch (showState)
			{
			case SW_MAXIMIZE:
				toolBarRestrictions.appBeingMaxed = APP_MAXIMIZING;
				ShowWindowAsync(WindowhWnd, showState);
				break;
			case SW_RESTORE:
				SendMessage(WindowhWnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
				break;
			case SW_MINIMIZE:
				SendMessage(WindowhWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0L); // REB 3/29/10 #22878 
				break;
			default:
				ShowWindowAsync(WindowhWnd, showState);
				break;
			}
		}
		else{
			ShowWindowAsync(WindowhWnd, showState);
		}
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: sys_GetUserName( PA_PluginParameters params )
//

void sys_GetUserName(PA_PluginParameters params)
{
	LONG_PTR userName_len;
	char userName[255];
	LONG_PTR returnValue;

	userName_len = PA_GetTextParameter(params, 1, userName);
	userName[userName_len] = '\0';  // Explicitly set the length

	userName_len = 255;  // This holds the maximum size of userName variable

	if (GetUserName(userName, &userName_len)) {
		returnValue = 1;
	}
	else {
		strcpy(userName, "");
		returnValue = 0;
	}

	// At this point, the user name field is either empty or filled
	// with a valid value.  Return this value to the user in either case.
	userName_len = strlen(userName);
	PA_SetTextParameter(params, 1, userName, userName_len);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetWindowTitle( PA_PluginParameters params )
//

void gui_SetWindowTitle(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR windowTitle_len;
	char windowTitle[255];
	LONG_PTR returnValue;
	HWND WindowhWnd;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal handle array
	windowTitle_len = PA_GetTextParameter(params, 2, windowTitle);
	windowTitle[windowTitle_len] = '\0';  // Explicitly set the length

	if (isEx){ // WJF 9/16/15 #43731 
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		SetWindowText(WindowhWnd, windowTitle);
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: sys_IsMultiByte( PA_PluginParameters params )
//

void sys_IsMultiByte(PA_PluginParameters params)
{
	LONG_PTR byte_len;
	char byte[255];
	LONG_PTR returnValue;

	byte_len = PA_GetTextParameter(params, 1, byte);

	returnValue = IsDBCSLeadByte(*byte);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_DisableCloseBox( PA_PluginParameters params )
//
//
//	MODIFICATIONS: 09/09/02 Added functionality to restore the close box.
//								 Pass in the window handle as a negative to restore.

void gui_DisableCloseBox(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR			hWndIndex;
	LONG_PTR			returnValue;
	HWND				WindowhWnd;
	HMENU				hSysMenu;
	BOOL				bUndo = FALSE;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 Changed to Index

	if (hWndIndex < 0) {
		bUndo = TRUE;
	}

	if (isEx){ // WJF 9/16/15 #43731 Added Ex version to use internal handle Array
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		hSysMenu = GetSystemMenu(WindowhWnd, 0);
		if (!bUndo) {
			EnableMenuItem(hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
		}
		else {
			EnableMenuItem(hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
		}
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetWindowLong( PA_PluginParameters params )
//
//  PURPOSE:  Multipurpose function to set window styles etc
//

void gui_SetWindowLong(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR s;
	LONG_PTR mode;
	LONG_PTR level;
	LONG_PTR returnValue;
	HWND WindowhWnd;
	LONG style;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 8/31/15 #43731 Changed to index from handle to make 64-bit safe
	s = PA_GetLongParameter(params, 2);
	mode = PA_GetLongParameter(params, 3);
	level = PA_GetLongParameter(params, 4);

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {

		if (level == 0)
			style = GetWindowLong(WindowhWnd, GWL_STYLE);
		else
			style = GetWindowLong(WindowhWnd, GWL_EXSTYLE);

		if (mode == 1)
			style |= (s);
		else
			style &= ~(s);

		if (level == 0)
			SetWindowLong(WindowhWnd, GWL_STYLE, style);
		else
			SetWindowLong(WindowhWnd, GWL_EXSTYLE, style);

		SetWindowPos(WindowhWnd, HWND_TOP, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_WinHelp( PA_PluginParameters params )
//
void gui_WinHelp(PA_PluginParameters params)
{
	LONG_PTR hWnd;
	LONG_PTR fileName_len;
	char fileName[255];
	LONG_PTR helpCommand;
	LONG_PTR helpData;
	LONG_PTR returnValue;
	HWND WindowhWnd;
	INT_PTR ret;

	hWnd = PA_GetLongParameter(params, 1);
	fileName_len = PA_GetTextParameter(params, 2, fileName);
	fileName[fileName_len] = '\0';  // Explicitly set the length
	helpCommand = PA_GetLongParameter(params, 3);
	helpData = PA_GetLongParameter(params, 4);


	WindowhWnd = (HWND)hWnd;
	if (IsWindow(WindowhWnd)) {
		ret = WinHelp(WindowhWnd, fileName, helpCommand, helpData);
		returnValue = (LONG_PTR)ret;
	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}



// ------------------------------------------------
// 
//  FUNCTION: gui_DelMenuItem( PA_PluginParameters params )
//

void gui_DelMenuItem(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR menuNum;
	LONG_PTR menuItem;
	LONG_PTR returnValue;
	HWND WindowhWnd;
	HMENU hSubMenu, hMenu;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 Changed to get index of internal handle array
	menuNum = PA_GetLongParameter(params, 2);
	menuItem = PA_GetLongParameter(params, 3);

	returnValue = 0;
	
	if (isEx){ // WJF 9/16/15 #43731 Added ex version to use internal handle array
		WindowhWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
	}

	if (IsWindow(WindowhWnd)) {
		hMenu = GetMenu(WindowhWnd);
		if (IsMenu(hMenu)) {
			hSubMenu = GetSubMenu(hMenu, menuNum);
			if (IsMenu(hSubMenu)) {
				RemoveMenu(hSubMenu, (menuItem)-1, MF_BYPOSITION);
				DrawMenuBar(WindowhWnd);
				returnValue = 1;
			}
		}
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetOpenFileName( PA_PluginParameters params )
//
//  PURPOSE:  display open file common dialog for selecting a file
//
//  COMMENTS: several optins are allowed which hide various
//						buttons or disable entry controls.
//						Uses a hook procedure and a template for folder
//						selection.       
//						Does not open file - only retieves name and path
//	DATE:			07/27/01
//
void gui_GetOpenFileName(PA_PluginParameters params)
{
	LONG_PTR		windowTitle_len;
	char		windowTitle[100];
	LONG_PTR		filePattern_len;
	char		filePattern[100];
	LONG_PTR		fileDescription_len;
	char		fileDescription[100];
	LONG_PTR		startFolder_len;
	char		startFolder[255];
	LONG_PTR		fileNameShort_len;
	char		fileNameShort[255];
	char		fileNameSuggested[255];
	LONG_PTR		fileNameSuggested_len;
	LONG_PTR		fileNameFull_len;
	char		fileNameFull[255];
	LONG_PTR		returnValue;
	OPENFILENAME ofn;
	unsigned char fileOpenPattern[80];
	LONG_PTR		mustExistOption = 0;
	BOOL		bUnhookSuccess;
	HWND		hWnd;
	char		plugInPath[255];
	PA_Unistring		Unistring;
	char				*pathName, *charPos;
	char				cCurrentPath[FILENAME_MAX];

	_getcwd(cCurrentPath, sizeof(cCurrentPath)); // WJF 2/20/15 #41921 Back up the current working directory
	g_FolderSelected = FALSE;  // MJG 6/15/05
	windowHandles.openSaveTBhwnd = NULL;

	if (PA_Is4DServer()){
		Unistring = PA_GetApplicationFullPath();
		pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
		charPos = strrchr(pathName, '\\');
		*charPos = 0;
		hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
		free(pathName); // WJF 6/9/15 #42792
	}
	else{
		hWnd = PA_GetHWND(NULL); // the current frontmost window
	}
	//hWnd = (HWND)PA_GetHWND(0);

	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';  // Explicitly set the length
	filePattern_len = PA_GetTextParameter(params, 2, filePattern);
	filePattern[filePattern_len] = '\0';  // Explicitly set the length
	fileDescription_len = PA_GetTextParameter(params, 3, fileDescription);
	fileDescription[fileDescription_len] = '\0';  // Explicitly set the length
	startFolder_len = PA_GetTextParameter(params, 4, startFolder);
	startFolder[startFolder_len] = '\0';  // Explicitly set the length
	fileNameSuggested_len = PA_GetTextParameter(params, 5, fileNameSuggested);
	fileNameSuggested[fileNameSuggested_len] = '\0';  // Explicitly set the length
	fileNameFull_len = PA_GetTextParameter(params, 6, fileNameFull);
	fileNameFull[fileNameFull_len] = '\0';  // Explicitly set the length

	mustExistOption = PA_GetLongParameter(params, 7);
	FD_Flags = mustExistOption;

	// The pattern consists of two strings, each terminated with a null character
	sprintf(fileOpenPattern, "%s%c%s%c", fileDescription, '\0', filePattern, '\0');

	GetPlugInFullName(plugInPath);

	memset(&ofn, 0, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = GetModuleHandle(plugInPath);
	ofn.lpstrFilter = fileOpenPattern;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = fileNameSuggested;
	ofn.nMaxFile = 255;
	ofn.lpstrFileTitle = fileNameShort;
	ofn.nMaxFileTitle = 255;
	ofn.lpstrInitialDir = startFolder;
	ofn.lpstrTitle = windowTitle;
	ofn.lpTemplateName = MAKEINTRESOURCE(IDD_COMDLG32);
	ofn.lpfnHook = ComDlg32DlgProc;
	ofn.Flags = OFN_EXPLORER;

	// Set the return strings to empty
	strcpy(fileNameShort, "");
	strcpy(fileNameFull, "");


	if ((FD_Flags & FD_HIDE_UP_BUTTON) | (FD_Flags & FD_DISABLE_EDIT_FIELD)
		| (FD_Flags & FD_DISABLE_LOOKIN_FIELD) | (FD_Flags & FD_FILES_ONLY)
		| (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) | (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON)
		| (FD_Flags & FD_SELECT_DIRECTORY)) {
		ofn.Flags = ofn.Flags | OFN_ENABLEHOOK;
	}

	if (FD_Flags & FD_FILE_MUST_EXIST) {
		ofn.Flags = ofn.Flags | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	}

	if (FD_Flags == FD_CREATE_PROMPT) {
		ofn.Flags = ofn.Flags | OFN_CREATEPROMPT;
	}

	if (FD_Flags == FD_SELECT_DIRECTORY) {
		strcpy(ofn.lpstrFile, ""); //with this option, cannot use a suggested filename 
		ofn.Flags = ofn.Flags | OFN_ENABLETEMPLATE;
	}

	if (GetOpenFileName(&ofn)) {
		returnValue = 1;
	}
	else {
		if (g_FolderSelected == TRUE){
			returnValue = 1;
		}
		else{
			ProcessCDError(CommDlgExtendedError(), hWnd);
			returnValue = 0;
		}
	}

	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.openSaveHookHndl); // success is non-zero
	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.postProcHookHndl);

	// At this point, the file name fields are either empty or filled
	// with valid values.  Return these values to the user in either case.
	if (FD_Flags & FD_SELECT_DIRECTORY) {
		strcpy(fileNameShort, intrProcStr1);
		strcpy(fileNameFull, intrProcStr1);
	}
	else {
		strcpy(fileNameFull, fileNameSuggested);
	}

	fileNameShort_len = strlen(fileNameShort);
	fileNameFull_len = strlen(fileNameFull);
	PA_SetTextParameter(params, 5, fileNameShort, fileNameShort_len);
	PA_SetTextParameter(params, 6, fileNameFull, fileNameFull_len);

	_chdir(cCurrentPath); // WJF 2/20/15 #41921 Restoring the current working directory will prevent folders from becoming incorrectly locked

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetSaveFileName( PA_PluginParameters params )
//
//  PURPOSE: Save File Common Dialog -- for saving a file 
//
//  COMMENTS:  see comments for OpenFileName
//
//	DATE:	07/21/01
//
void gui_GetSaveFileName(PA_PluginParameters params)
{
	LONG_PTR		windowTitle_len;
	char		windowTitle[100];
	LONG_PTR		filePattern_len;
	char		filePattern[100];
	LONG_PTR		fileDescription_len;
	char		fileDescription[100];
	LONG_PTR		startFolder_len;
	char		startFolder[255];
	LONG_PTR		fileNameShort_len;
	char		fileNameShort[255];
	char		fileNameSuggested[255];
	LONG_PTR		fileNameSuggested_len;
	LONG_PTR		fileNameFull_len;
	char		fileNameFull[255];
	LONG_PTR		returnValue;
	OPENFILENAME ofn;
	unsigned char fileOpenPattern[80];
	LONG_PTR		mustExistOption = 0;
	BOOL		bUnhookSuccess;
	HWND		hWnd;
	char		plugInPath[255];
	PA_Unistring		Unistring;
	char				*pathName, *charPos;

	g_FolderSelected = FALSE;  // MJG 6/15/05
	windowHandles.openSaveTBhwnd = NULL;

	if (PA_Is4DServer()){
		Unistring = PA_GetApplicationFullPath();
		pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322
		charPos = strrchr(pathName, '\\');
		*charPos = 0;
		hWnd = FindWindowEx(NULL, NULL, pathName, NULL);
		free(pathName); // WJF 6/25/15 #42792
	}
	else{
		hWnd = PA_GetHWND(NULL); // the current frontmost window
	}
	//hWnd = (HWND)	PA_GetHWND(0);

	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';  // Explicitly set the length
	filePattern_len = PA_GetTextParameter(params, 2, filePattern);
	filePattern[filePattern_len] = '\0';  // Explicitly set the length
	fileDescription_len = PA_GetTextParameter(params, 3, fileDescription);
	fileDescription[fileDescription_len] = '\0';  // Explicitly set the length
	startFolder_len = PA_GetTextParameter(params, 4, startFolder);
	startFolder[startFolder_len] = '\0';  // Explicitly set the length
	fileNameSuggested_len = PA_GetTextParameter(params, 5, fileNameSuggested);
	fileNameSuggested[fileNameSuggested_len] = '\0';  // Explicitly set the length
	fileNameFull_len = PA_GetTextParameter(params, 6, fileNameFull);
	fileNameFull[fileNameFull_len] = '\0';  // Explicitly set the length

	mustExistOption = PA_GetLongParameter(params, 7);
	FD_Flags = mustExistOption;

	// The pattern consists of two strings, each terminated with a null character
	sprintf(fileOpenPattern, "%s%c%s%c", fileDescription, '\0', filePattern, '\0');

	// Set the return strings to empty
	strcpy(fileNameShort, "");
	strcpy(fileNameFull, "");

	GetPlugInFullName(plugInPath);

	memset(&ofn, 0, sizeof(ofn));
	ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = GetModuleHandle(plugInPath);
	ofn.lpstrFilter = fileOpenPattern;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = fileNameSuggested;
	ofn.nMaxFile = 255;
	ofn.lpstrFileTitle = fileNameShort;
	ofn.nMaxFileTitle = 255;
	ofn.lpstrInitialDir = startFolder;
	ofn.lpstrTitle = windowTitle;
	ofn.lpTemplateName = MAKEINTRESOURCE(IDD_COMDLG32);
	ofn.lpfnHook = ComDlg32DlgProc;
	ofn.Flags = OFN_EXPLORER;

	if ((FD_Flags & FD_HIDE_UP_BUTTON) | (FD_Flags & FD_DISABLE_EDIT_FIELD)
		| (FD_Flags & FD_DISABLE_LOOKIN_FIELD) | (FD_Flags & FD_FILES_ONLY)
		| (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) | (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON)
		| (FD_Flags & FD_SELECT_DIRECTORY)) {
		ofn.Flags = ofn.Flags | OFN_ENABLEHOOK;
	}

	if (FD_Flags & FD_FILE_MUST_EXIST) {
		ofn.Flags = ofn.Flags | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	}

	if (FD_Flags == FD_OVERWRITE_PROMPT) {
		ofn.Flags = ofn.Flags | OFN_OVERWRITEPROMPT;
	}

	if (FD_Flags == FD_SELECT_DIRECTORY) {
		strcpy(ofn.lpstrFile, ""); //with this option, cannot use a suggested filename 
		ofn.Flags = ofn.Flags | OFN_ENABLETEMPLATE;
	}

	if (GetSaveFileName(&ofn)) {
		returnValue = 1;
	}
	else {
		if (g_FolderSelected == TRUE){
			returnValue = 1;
		}
		else{
			ProcessCDError(CommDlgExtendedError(), hWnd); // primarily for debugging
			returnValue = 0;
		}
	}

	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.openSaveHookHndl); // success is non-zero
	bUnhookSuccess = UnhookWindowsHookEx(hookHandles.postProcHookHndl);

	// At this point, the file name fields are either empty or filled
	// with valid values.  Return these values to the user in either case.
	if (FD_Flags & FD_SELECT_DIRECTORY) {
		strcpy(fileNameShort, intrProcStr1);
		strcpy(fileNameFull, intrProcStr1);
	}
	else {
		strcpy(fileNameFull, fileNameSuggested);
	}

	fileNameShort_len = strlen(fileNameShort);
	fileNameFull_len = strlen(fileNameFull);
	PA_SetTextParameter(params, 5, fileNameShort, fileNameShort_len);
	PA_SetTextParameter(params, 6, fileNameFull, fileNameFull_len);

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_LoadIcon( PA_PluginParameters params )
//

void gui_LoadIcon(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR iconName_len;
	char iconName[255];  //complete path of icon file
	LONG_PTR hIcon;
	LONG_PTR returnValue;
	HICON tmpIcon;
	DWORD iconIndex = 0;

	iconName_len = PA_GetTextParameter(params, 1, iconName);
	iconName[iconName_len] = '\0';  // Explicitly set the length

	hIcon = PA_GetLongParameter(params, 2);

	// Load the icon
	hIcon = 0;
	tmpIcon = (HICON)LoadImage(0, iconName, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);

	if (tmpIcon != 0) {
		hIcon = (LONG_PTR)tmpIcon;
		returnValue = 1;
	}
	else {
		returnValue = 0;
	}

	if (isEx){ // WJF 9/16/15 #43731
		iconIndex = handleArray_add(hIcon); 
		PA_SetLongParameter(params, 2, iconIndex); 
	}
	else {
		PA_SetLongParameter(params, 2, hIcon);
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_SetIcon( PA_PluginParameters params )
//

void gui_SetIcon(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR hWndIndex;
	LONG_PTR hIconIndex;
	LONG_PTR returnValue;
	LONG_PTR hIcon;
	HWND WindowhWnd;

	// WJF 9/1/15 #43731 We are now getting indexes to an internal array
	hWndIndex = PA_GetLongParameter(params, 1); 
	hIconIndex = PA_GetLongParameter(params, 2);

	if (isEx){ // WJF 9/16/15 #43731
		WindowhWnd = handleArray_retrieve(hWndIndex); 
		hIcon = (LONG_PTR)handleArray_retrieve(hIconIndex);
	}
	else {
		WindowhWnd = (HWND)hWndIndex;
		hIcon = hIconIndex;
	}

	if ((IsWindow(WindowhWnd)) && (hIcon != 0)) {

		// Tell the window to use this icon
		SendMessage(WindowhWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)(HICON)hIcon);
		returnValue = 1;

	}
	else {
		returnValue = 0;
	}

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetWindowFrom4DWin( PA_PluginParameters params )
//

void gui_GetWindowFrom4DWin(PA_PluginParameters params)
{
	LONG_PTR h4DWnd = 0;
	LONG_PTR windowHandle = 0; 
	LONG_PTR serverValue = 0;
	long returnValue = 0;

	h4DWnd = PA_GetLongParameter(params, 1);
	serverValue = PA_GetLongParameter(params, 2);

	if (serverValue == 1) // AMS 5/20/14 #39556 PA_GetHWND(h4DWnd) does not work on 4D Server // AMS 6/8/14 #39789
	{
		windowHandle = PA_GetHWND(PA_GetWindowFocused());
	}
	else
	{
		windowHandle = PA_GetHWND(h4DWnd);
	}

	returnValue = (long)windowHandle;

	PA_ReturnLong(params, returnValue);
}


// ------------------------------------------------
// 
//  FUNCTION: sys_GetRegionSettings( PA_PluginParameters params, BOOL arraySupplied )
//
//  PURPOSE:	Gets region-specifiuc settings such as decimal char, currency symbol etc
//
//  COMMENTS: Method gets all or one depending on 2nd parameter passed from
//						entry point.

//	DATE:			dcc 07/10/01
//
void sys_GetRegionSettings(PA_PluginParameters params, BOOL arraySupplied)
{
	PA_Variable	values, valueDescr;
	char		textParam[80];
	LONG_PTR		textParam_len;
	LCTYPE	infoType[NBR_ELEMENTS];
	char*		description[] = {
		"Short Date", "Long Date", "Date Separator", "Time Format",
		"Time Separator", "AM Symbol", "PM Symbol", "Measurement System",
		"Decimal Symbol", "Leading Zeros", "Digits after Decimal",
		"Number Grouping Symbol", "Negative Symbol", "Currency Symbol",
		"Currency Decimal Symbol", "Currency Digits after Decimal",
		"Currency Grouping Symbol", "List Separator"
	};
	LONG_PTR		returnValue, i, loopStop, gliReturnValue;  //gli = GetLocaleInfo
	LONG_PTR		requestedSetting;
	char		resultString[255];
	char		sz[255];
	INT_PTR			bufSize = 255, resultSize = 255;

	infoType[0] = LOCALE_SSHORTDATE;
	infoType[1] = LOCALE_SLONGDATE;
	infoType[2] = LOCALE_SDATE;
	infoType[3] = LOCALE_STIMEFORMAT;
	infoType[4] = LOCALE_STIME;
	infoType[5] = LOCALE_S1159;
	infoType[6] = LOCALE_S2359;
	infoType[7] = LOCALE_IMEASURE;
	infoType[8] = LOCALE_SDECIMAL;
	infoType[9] = LOCALE_ILZERO;
	infoType[10] = LOCALE_IDIGITS;
	infoType[11] = LOCALE_STHOUSAND;
	infoType[12] = LOCALE_SNEGATIVESIGN;
	infoType[13] = LOCALE_SCURRENCY;
	infoType[14] = LOCALE_SMONDECIMALSEP;
	infoType[15] = LOCALE_ICURRDIGITS;
	infoType[16] = LOCALE_SMONTHOUSANDSEP;
	infoType[17] = LOCALE_SLIST;

	returnValue = 0;
	if (arraySupplied) {
		values = PA_GetVariableParameter(params, 1);
		PA_ResizeArray(&values, NBR_ELEMENTS);

		valueDescr = PA_GetVariableParameter(params, 2);
		PA_ResizeArray(&valueDescr, NBR_ELEMENTS);

		loopStop = PA_GetArrayNbElements(values);
		requestedSetting = 0; // start at zero in loop below to get all into the array
	}
	else {
		textParam_len = PA_GetTextParameter(params, 1, textParam);
		loopStop = PA_GetLongParameter(params, 2);
		requestedSetting = loopStop - 1;
	}


	for (i = requestedSetting; i < loopStop; i++)
	{
		strcpy(sz, resultString);
		resultSize = strlen(sz);
		gliReturnValue = GetLocaleInfo(LOCALE_USER_DEFAULT, infoType[i], sz, bufSize);
		if (gliReturnValue = 0) {
			strcpy(sz, "n/a"); // some keyNames may be there & some may not
		}

		if (infoType[i] == LOCALE_IMEASURE) {
			if (sz[0] == '0') {
				strcpy(sz, "Metric");
			}
			else {
				strcpy(sz, "U.S.");
			} //(sz[0] == '0')
		} //(infoType[i] == LOCALE_IMEASURE)

		if (arraySupplied) {
			PA_SetTextInArray(values, i + 1, sz, strlen(sz));
			PA_SetTextInArray(valueDescr, i + 1, description[i], strlen(description[i]));
			returnValue = i + 1;
		}
		else {
			PA_SetTextParameter(params, 1, sz, strlen(sz));
			PA_ReturnLong(params, strlen(sz));  // return value string length
			return;
		} //(arraySupplied)

	} //(i = requestedSetting; i < loopStop; i++)

	PA_SetVariableParameter(params, 1, values, 0);
	PA_SetVariableParameter(params, 2, valueDescr, 0);
	PA_ReturnLong(params, returnValue);

}

// ------------------------------------------------
// 
//  FUNCTION: sys_GetTimeZone( PA_PluginParameters params )
//
//  PURPOSE:	Gets time zone setting of cmptr	
//
//  COMMENTS: Requires two text strings and a LONG_PTR
//						Returns name of standard time, name of daylight time, and
//						flag if cmptr set to auto adjust for daylight savings changes.
//
//						IMPORTANT:  It is imperative that different name & size variables be 
//												used for query on standard time and daylight time.
//												The problem is in release configuration mode where the size
//												returned from first use does not get reset properly (even
//												when set explicitly).  This is alluded to in help file
//												documentation.
//	DATE:			dcc 07/16/01
//
//  REB 1/21/09 #19035  Updated how we retrieve time zone information.  Original code commented out.
//

void sys_GetTimeZone(PA_PluginParameters params)
{
	LONG_PTR		standardName_len;
	char		standardName[255];
	LONG_PTR		daylightName_len;
	char		daylightName[255];
	LONG_PTR		autoDaylight = 0;
	LONG_PTR		returnValue;
	TIME_ZONE_INFORMATION TimeZoneInformation; // REB 1/21/09 #19035

	returnValue = 1;

	GetTimeZoneInformation(&TimeZoneInformation);

	wcstombs(standardName, TimeZoneInformation.StandardName, 255);
	standardName_len = strlen(standardName);

	wcstombs(daylightName, TimeZoneInformation.DaylightName, 255);
	daylightName_len = strlen((char *)daylightName);

	if (TimeZoneInformation.DaylightBias != 0){
		autoDaylight = 1;
	}
	else{
		autoDaylight = 0;
	}

	PA_SetTextParameter(params, 1, (char *)standardName, standardName_len);
	PA_SetTextParameter(params, 2, (char *)daylightName, daylightName_len);
	PA_SetLongParameter(params, 3, autoDaylight);

	PA_ReturnLong(params, returnValue);

}

// ------------------------------------------------
// 
//  FUNCTION: sys_GetUTCOffset ( PA_PluginParameters params )
//
//  REB 1/21/09 #19035 Updated to use GetTimeZoneInformation

void sys_GetUTCOffset(PA_PluginParameters params)
{
	LONG_PTR					returnValue = 0;
	LONG_PTR					bias = 0, weekNum = 0;

	//struct _timeb tstruct;
	TIME_ZONE_INFORMATION TimeZoneInformation; // REB 1/21/09 #19035
	SYSTEMTIME SystemTime;

	GetTimeZoneInformation(&TimeZoneInformation);
	GetLocalTime(&SystemTime);

	bias = TimeZoneInformation.Bias;

	//TimeZoneInformation.DaylightDate.wDayOfWeek // Sun - Sat
	//TimeZoneInformation.DaylightDate.wDay // 1 -5 occurance of above day

	// Calculate which occurance of the current day we are on.  Basically which week in the month we are on.
	weekNum = ((SystemTime.wDay - 1) / 7) + 1; // Between 1 and 5


	if (SystemTime.wMonth == TimeZoneInformation.StandardDate.wMonth){
		// We are in the month when we change back to standard
		if (SystemTime.wDayOfWeek == TimeZoneInformation.StandardDate.wDayOfWeek){
			// We are in the Week that the time changes
			if (weekNum == TimeZoneInformation.StandardDate.wDay){
				// This is the Day the time changes
				if (SystemTime.wHour >= TimeZoneInformation.StandardDate.wHour){
					bias += TimeZoneInformation.StandardBias;
				}
				else{
					bias += TimeZoneInformation.DaylightBias;
				};
			}
			else if (weekNum > TimeZoneInformation.StandardDate.wDay){
				bias += TimeZoneInformation.StandardBias;
			}
			else{
				bias += TimeZoneInformation.DaylightBias;
			};
		}
		else if (SystemTime.wDayOfWeek > TimeZoneInformation.StandardDate.wDayOfWeek){
			if (weekNum > TimeZoneInformation.StandardDate.wDay){
				bias += TimeZoneInformation.StandardBias;
			}
			else{
				bias += TimeZoneInformation.DaylightBias;
			};
		}
		else{
			bias += TimeZoneInformation.DaylightBias;
		};

	}
	else if (SystemTime.wMonth == TimeZoneInformation.DaylightDate.wMonth){
		// We are in the month when we change back to standard
		if (SystemTime.wDayOfWeek == TimeZoneInformation.DaylightDate.wDayOfWeek){
			// We are in the Week that the time changes
			if (weekNum == TimeZoneInformation.DaylightDate.wDay){
				// This is the Day the time changes
				if (SystemTime.wHour >= TimeZoneInformation.DaylightDate.wHour){
					bias += TimeZoneInformation.DaylightBias;
				}
				else{
					bias += TimeZoneInformation.StandardBias;
				};
			}
			else if (weekNum > TimeZoneInformation.DaylightDate.wDay){
				bias += TimeZoneInformation.DaylightBias;
			}
			else{
				bias += TimeZoneInformation.StandardBias;
			};
		}
		else if (SystemTime.wDayOfWeek > TimeZoneInformation.DaylightDate.wDayOfWeek){
			if (weekNum > TimeZoneInformation.DaylightDate.wDay){
				bias += TimeZoneInformation.DaylightBias;
			}
			else{
				bias += TimeZoneInformation.StandardBias;
			};
		}
		else{
			bias += TimeZoneInformation.StandardBias;
		};

	}
	else if (TimeZoneInformation.StandardDate.wMonth > TimeZoneInformation.DaylightDate.wMonth){
		// The period of daylight savings time uccurs within a single year.
		if ((SystemTime.wMonth > TimeZoneInformation.DaylightDate.wMonth) && (SystemTime.wMonth < TimeZoneInformation.StandardDate.wMonth)){
			bias += TimeZoneInformation.DaylightBias;
		}
		else{
			bias += TimeZoneInformation.StandardBias;
		};

	}
	else{
		// The period of daylight savings time is split between 2 years (say, November to April). 
		if ((SystemTime.wMonth > TimeZoneInformation.DaylightDate.wMonth) || (SystemTime.wMonth < TimeZoneInformation.StandardDate.wMonth)){
			bias += TimeZoneInformation.DaylightBias;
		}
		else{
			bias += TimeZoneInformation.StandardBias;
		};
	};


	PA_SetLongParameter(params, 1, bias);

	returnValue = PA_GetLongParameter(params, 1);
	//_tzset();
	//_ftime( &tstruct );
	//PA_SetLongParameter( params, 1, tstruct.timezone );
	if (returnValue == TIME_ZONE_ID_INVALID){
		returnValue = 0;
	}
	else{
		returnValue = 1;
	};

	PA_ReturnLong(params, returnValue);
}

// ------------------------------------------------
// 
//  FUNCTION: gui_GetDisplayFontDPI( PA_PluginParameters params)
//
//	DATE:			dcc 07/??/01  <-- Was the calendar broken that day?
//
void gui_GetDisplayFontDPI(PA_PluginParameters params)
{
	LONG_PTR		dpi = 0;
	char		subKey[100];
	LONG_PTR		returnValue, errorCode;
	HKEY		hKey;
	DWORD		dwWordType = REG_DWORD;
	DWORD		dwWordSize = sizeof(DWORD);
	DWORD		dwSZSize = 255;
	DWORD		dwDPI;

	returnValue = 0;

	strcpy(subKey, "Software\\Microsoft\\Windows NT\\CurrentVersion\\FontDPI");
	hKey = HKEY_LOCAL_MACHINE;
	errorCode = RegOpenKeyEx(hKey, subKey, 0, KEY_READ, &hKey);
	if (errorCode != ERROR_SUCCESS) {
		returnValue = 0;
		PA_ReturnLong(params, returnValue);
		return;
	}
	errorCode = RegQueryValueEx(hKey, "LogPixels", NULL, &dwWordType, (PCHAR)&dwDPI, &dwWordSize);
	if (errorCode != ERROR_SUCCESS) {
		returnValue = 0;
		PA_ReturnLong(params, returnValue);
		return;
	}
	else {
		dpi = dwDPI;
	}
	errorCode = RegCloseKey(hKey);

	PA_SetLongParameter(params, 1, dpi);
	returnValue = dpi;
	PA_ReturnLong(params, returnValue);

}


// ------------------------------------------------
// 
//  FUNCTION: sys_GetDefPrinter( PA_PluginParameters params )
//
//  PURPOSE:  Determines which printer is marked as default
//		REB 3/6/09 #17333 Updated to work with Windows Vista and beyond.
//		REB 8/11/09		Removed logic used in versions of Windows older than 2000.
//
void sys_GetDefPrinter(PA_PluginParameters params)
{
	LONG_PTR printerName_len;
	char printerName[255];
	char *pDefaultPrinter;				// REB 3/6/09 #17333 
	LONG_PTR returnValue;
	ULONG_PTR ulBytesNeeded;		// REB 3/6/09 #17333 

	printerName_len = PA_GetTextParameter(params, 1, printerName);
	printerName[printerName_len] = '\0';  // Explicitly set the length

	printerName_len = 255;  // This holds the maximum size of printerName variable
	ulBytesNeeded = MAXBUF;

	pDefaultPrinter = (char *)malloc(ulBytesNeeded);
	memset(pDefaultPrinter, 0, ulBytesNeeded);

	returnValue = GetDefaultPrinter(pDefaultPrinter, &ulBytesNeeded);
	strcpy(printerName, pDefaultPrinter);

	free(pDefaultPrinter); // WJF 6/4/15 #42921

	// At this point, the printer name field is either empty or filled
	// with a valid value.  Return this value to the user in either case.
	printerName_len = strlen(printerName);
	PA_SetTextParameter(params, 1, printerName, printerName_len);

	PA_ReturnLong(params, returnValue);
}


// ------------------------------------------------
// 
//  FUNCTION: sys_SetDefPrinter( PA_PluginParameters params )
//
//  PURPOSE:  Sets the default printer
//
void sys_SetDefPrinter(PA_PluginParameters params)
{
	LONG_PTR printerName_len;
	char printerName[255];
	char tempName[255];					// REB 3/6/09 #17333 Printer name after spooler info is removed
	char separator[] = ",";				// REB 3/6/09 #17333 Separates printer name from spooler info
	BOOL returnValue;

	printerName_len = PA_GetTextParameter(params, 1, printerName);
	printerName[printerName_len] = '\0';  // Explicitly set the length


	// REB 3/6/09 #17333 Remove spooler info from printer name.
	printerName_len = strcspn(printerName, separator);
	if (printerName_len > 0){
		strncpy(tempName, printerName, printerName_len);
		tempName[printerName_len] = '\0';
		returnValue = SetDefaultPrinter(tempName);
	}

	PA_ReturnLong(params, (LONG_PTR)returnValue);
}



// ------------------------------------------------
// 
//  FUNCTION: sys_GetOSVersion(BOOL bInternalCall, PA_PluginParameters params)
//
//  PURPOSE:  Get version of operating system
//
//  COMMENTS: Internally returns LONG_PTR that corresponds to constant defined
//			  for each OS.  params are ignored on internal calls.
//			  External call gets version as constant and string for service pack.
//			  Some info is in win.ini file (Win95/98/Me) and some
//			  in registry.  Need to know where to go hunting
//	DATE:	  dcc 07/10/01
//
//	MODIFICATIONS: 12/1/03 Added check for Windows Server 2003.
//				   7/15/09 Added check for Windows 7 
//				   10/31/12 Added support for Windows 8 and Server 2012
//			       AMS2 9/26/14 #37816 Windows 8.1 and Server 2012 R2 and newer versions of Windows should use sys_GetOSVersionEX as GetVersionEX is deprecated
//            
//
LONG_PTR sys_GetOSVersion(BOOL bInternalCall, PA_PluginParameters params)
{

	OSVERSIONINFOEX		osvinfo;
	LONG_PTR			returnValue = 0;
	char				servicePackInfo[255] = "";
	char				filePath[MAX_PATH] = "";
	FILE				*fp = NULL;
	char				utilitiesPath[MAX_PATH] = "";
	char				*pos = NULL;
	char				osVer[16] = "";

	osvinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	GetVersionEx(&osvinfo);

	if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_WIN95;
	}
	else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 10) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_WIN98;
	}
	else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 90) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)) {
		returnValue = OS_ME;
	}
	else if ((osvinfo.dwMajorVersion == 3) & (osvinfo.dwMinorVersion == 51) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_NT351;
	}
	else if ((osvinfo.dwMajorVersion == 4) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_NT4;
	}
	else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_W2K;
	}
	else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_XP;
	}
	else if ((osvinfo.dwMajorVersion == 5) & (osvinfo.dwMinorVersion == 2) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)) {
		returnValue = OS_WIN03;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)& (osvinfo.wProductType == VER_NT_WORKSTATION)) {
		returnValue = OS_VISTA_LONGHORN;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 0) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)& (osvinfo.wProductType != VER_NT_WORKSTATION)) {
		returnValue = OS_SERVER2K8;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) & (osvinfo.wProductType == VER_NT_WORKSTATION)) {
		returnValue = OS_WIN7;
	}
	else if ((osvinfo.dwMajorVersion == 6) & (osvinfo.dwMinorVersion == 1) & (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) & (osvinfo.wProductType != VER_NT_WORKSTATION)) {
		returnValue = OS_SERVER2K8R2;
	}
	else
	{
		// WJF 9/22/15 #43601 Moved all version helper API calls to Orchard Utilities
		// AMS2 12/17/14 #37816 Because GetVersionEx is deprecated, new versions of windows need to use version helper API functions to detect the OS version along with defining the new version number.
		// Version numbers for current and new versions of windows are located at http://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx.
		/*if (IsWindows8OrGreater())
		{
			returnValue = OS_WIN8;
		}

		if (IsWindows8Point1OrGreater())
		{
			returnValue = OS_WIN81;
		}*/

		// WJF 9/21/15 #43601 Calling Orchard Utilities because it supports Windows 10 detection
		GetTempPath(MAX_PATH, filePath);

		strcat_s(filePath, MAX_PATH, "osVersion.txt");

		strcpy_s(utilitiesPath, MAX_PATH, pathName);

		pos = strrchr(utilitiesPath, '\\');

		strcpy_s(pos, MAX_PATH, "orchard_utilities.exe");

		ShellExecute(windowHandles.fourDhWnd, "", utilitiesPath, "-os", NULL, SW_HIDE);

		if (GetLastError() == ERROR_SUCCESS){
			utilitiesYield(filePath);

			fp = fopen(filePath, "r");

			if (fp){
				fgets(osVer, 16, fp);

				returnValue = atoi(osVer);
			}
		}

		// WJF 9/22/15 #43601 Removed
		/*if (IsWindowsServer())
		{
			++returnValue; // Server version numbers are the same as the OS version number but are incremented by one
		}*/
	}

	if (!bInternalCall) {
		PA_SetLongParameter(params, 1, returnValue);
		strcpy(servicePackInfo, osvinfo.szCSDVersion);
		PA_SetTextParameter(params, 2, servicePackInfo, strlen(servicePackInfo));
		PA_ReturnLong(params, returnValue);
	}
	return returnValue;
}


// *******   end of plugin call modules **********


// supporting modules ---------------------------------------------



// ------------------------------------------------
// 
//  FUNCTION:  ComDlg32DlgProc
//
//  PURPOSE:	Callback function for Open/Save FileName Dialog modifications
//
//  COMMENTS:  Some callback features inspired by Shanker Chandrabose's code
//							Kids -- don't try this at home :)
//
//	DATE:  07/21/01
//
BOOL CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	WORD		wNotifyCode = HIWORD(wParam);
	WORD		wID = LOWORD(wParam);
	TCHAR		szPathName[255];

	switch (uMsg)
	{
	case WM_INITDIALOG:
		EnumChildWindows((HWND)GetParent(hDlg), EnumChildProc, (LPARAM)NULL);
		hookHandles.openSaveHookHndl = SetWindowsHookEx(WH_CALLWNDPROC, (HOOKPROC)theHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
		hookHandles.postProcHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC)postHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
		g_parentHndl = hDlg;
		break;

	case WM_COMMAND:
		if ((wNotifyCode == BN_CLICKED) & (wID == IDC_BUTTON1)) {
			GetDlgItemText(g_parentHndl, IDE_SELECTED, szPathName, MAX_PATH);
			strcpy(intrProcStr1, szPathName);

			// MJG 4/29/05 Invoke cancel button.  Don't forcibly close dialog.
			//SendMessage(g_parentHndl, WM_COMMAND, (WM_USER + 31488), 0L);
			g_FolderSelected = TRUE;
			PostMessage(GetParent(g_parentHndl), WM_COMMAND, MAKEWPARAM(IDCANCEL, BN_CLICKED), 0);
		}

		break;

	case WM_NOTIFY:
		TestNotify(hDlg, (LPOFNOTIFY)lParam);

	default:
		return FALSE;
	}
	return TRUE;
}

// ------------------------------------------------
// 
//  FUNCTION: postHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Exit dialog using a different control
//
//  COMMENTS: OpenFile dialog has trouble closing without using		
//							IDOK, IDCANCEL or IDCLOSE.  IDOK requires
//							a file be selected.  A directory won't do.
//   
//	DATE:			dcc 07/30/01
//
LRESULT CALLBACK postHook(INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{

	/*
	CWPRETSTRUCT	*cwprs		= (CWPRETSTRUCT*)lParam;

	if (cwprs->message == WM_COMMAND) {
	if (cwprs->wParam == (WM_USER + 31488)) {
	EndDialog(g_parentHndl, TRUE); //end the child dialog
	EndDialog(GetParent(g_parentHndl), TRUE); // now end the main dialog (parent)
	return TRUE;
	}
	}
	*/
	return CallNextHookEx(hookHandles.postProcHookHndl, hCode, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: theHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Process disable and hide controls
//
//	DATE:			dcc 07/14/01
//
//	MODIFICATIONS:  08/13/02 Corrected problem where FD_HIDE_UP_BUTTON
//					and FD_HIDE_NEWDIRECTORY_BUTTON could not be used
//					together.
//					04/14/04 Improved efficiency when working with 
//                  FD_SELECT_DIRECTORY. 

LRESULT CALLBACK theHook(INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{

	TCHAR					szClassName[255];
	TCHAR					szItemName[255];
	TCHAR					szPathName[255];
	LVITEM				item;
	HANDLE				buttonToDisable;
	CWPSTRUCT			*cwps = (CWPSTRUCT*)lParam;
	TBBUTTONINFO	tbInfo;
	BOOL					bChangeHiddenState = TRUE, bSelectedItem = FALSE;
	static INT_PTR		tbOnetime = 0;
	INT_PTR						count, i;

	if (windowHandles.openSaveTBhwnd == NULL) {
		tbOnetime = 0;
	}
	GetClassName(cwps->hwnd, szClassName, 255);

	if (strcmp(_strlwr(szClassName), "toolbarwindow32") == 0) {
		if (!tbOnetime) {
			windowHandles.openSaveTBhwnd = cwps->hwnd;
			++tbOnetime;
			if (FD_Flags & FD_HIDE_TOOLBAR_BUTTONS) {
				bChangeHiddenState = ShowWindow(windowHandles.openSaveTBhwnd, SW_HIDE);
			}
		}
	}
	if (strcmp(_strlwr(szClassName), "syslistview32") == 0) {
		if ((FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) | (FD_Flags & FD_HIDE_UP_BUTTON)) {
			tbInfo.cbSize = sizeof(TBBUTTONINFO);
			tbInfo.dwMask = TBIF_STATE;
			tbInfo.fsState = TBSTATE_HIDDEN | TBSTATE_INDETERMINATE;
			if (FD_Flags & FD_HIDE_NEWDIRECTORY_BUTTON) {
				buttonToDisable = (HANDLE)NEWBUTTONFOLDER;
				SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM)&tbInfo);
			} //else { // 08/13/02 was either or.  Couldn't use both
			if (FD_Flags & FD_HIDE_UP_BUTTON) {
				buttonToDisable = (HANDLE)UPONELEVELBUTTON;
				SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM)&tbInfo);
			}
			//SendMessage(windowHandles.openSaveTBhwnd, TB_SETBUTTONINFO, (WPARAM)buttonToDisable, (LPARAM) &tbInfo);
		}

		switch (cwps->message)
		{
		case WM_NCPAINT:
		case LAST_LISTVIEW_MSG:
			if (FD_Flags & FD_FILES_ONLY) {  // 4/14/04 Only perform filter if FD_FILES_ONLY is set.
				count = ListView_GetItemCount(cwps->hwnd);
				for (i = 0; i < count; i++)
				{
					item.mask = LVIF_TEXT | LVIF_PARAM;
					item.iItem = i;
					item.iSubItem = 0;
					item.pszText = szItemName;
					item.cchTextMax = 255;
					ListView_GetItem(cwps->hwnd, &item);
					if (GetFileAttributes(szItemName) & FILE_ATTRIBUTE_DIRECTORY) {
						//if ( FD_Flags & FD_FILES_ONLY ) {
						ListView_DeleteItem(cwps->hwnd, i);
						//}
					}
				}  //end for
			}
			//break;


		case WM_NOTIFY:
			bSelectedItem = FALSE;
			strcpy(szPathName, "");

			if (FD_Flags & FD_SELECT_DIRECTORY) {  // 4/14/04 Only perform search if FD_SELECT_DIRECTORY is selected

				// 4/14/04 Modified the code to directly get the selected item instead of looping
				// through each item in the list.
				i = ListView_GetNextItem(cwps->hwnd, -1, LVNI_ALL | LVNI_SELECTED);

				//count = ListView_GetItemCount(cwps->hwnd);
				//for( i = 0; i < count; i++)
				if (i != -1)
				{
					strcpy(szItemName, "");
					item.mask = LVIF_TEXT | LVIF_STATE;
					item.iItem = i;
					item.iSubItem = 0;
					item.stateMask = LVIS_SELECTED;
					item.pszText = szItemName;
					item.cchTextMax = 255;
					ListView_GetItem(cwps->hwnd, &item);
					if (GetFileAttributes(szItemName) & FILE_ATTRIBUTE_DIRECTORY) {
						//if ( FD_Flags & FD_SELECT_DIRECTORY) {
						if (item.state & LVIS_SELECTED) {
							strcpy(szPathName, intrProcStr1);
							if (szPathName[strlen(szPathName) - 1] != '\\') {
								strcat(szPathName, "\\");
							}
							strcat(szPathName, szItemName);
							SetDlgItemText(g_parentHndl, IDE_SELECTED, szPathName);
							bSelectedItem = TRUE;
							//break;
						}
						//}
					}

				}  //end if

				if (!bSelectedItem) {
					strcpy(szPathName, intrProcStr2);
					if (strlen(szPathName) > 0) {
						SetDlgItemText(g_parentHndl, IDE_SELECTED, intrProcStr1);
					}
				}
			}

		}  // end switch
	} // if (strcmp(_strlwr(szClassName), "syslistview32") == 0)

	return CallNextHookEx(hookHandles.openSaveHookHndl, hCode, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam)
//
//  PURPOSE:	Disables Lookin and/or Edit controls in open/save dialogs
//
//  COMMENTS: Called in hook procedure of open/save dialogs
//						Global FD_Flags used to determine which option
//	DATE:			dcc 07/10/01
//
BOOL CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam)
{
	INT_PTR			ctrlID;
	BOOL		bWindowEnabled;
	ctrlID = GetDlgCtrlID(hWnd);

	switch (ctrlID)
	{
	case LOOK_IN_COMBO:
		if (FD_Flags & FD_DISABLE_LOOKIN_FIELD) {
			bWindowEnabled = EnableWindow(hWnd, FALSE);
		}
		break;
	case EDIT_FIELD:
		if (FD_Flags & FD_DISABLE_EDIT_FIELD) {
			bWindowEnabled = EnableWindow(hWnd, FALSE);
		}
		break;
	}

	return TRUE;
}


// ------------------------------------------------
// 
//  FUNCTION: TestNotify(HWND hDlg, LPOFNOTIFY pofn)
//
//  PURPOSE:  Used when Directory Selection is in play
//
//  COMMENTS:
//   
//	DATE:			dcc 07/23/01
//
BOOL NEAR PASCAL TestNotify(HWND hDlg, LPOFNOTIFY pofn)
{

	switch (pofn->hdr.code)
	{
	case CDN_SELCHANGE:
	case CDN_FOLDERCHANGE: // A new folder has been opened.
	{
							   char szFile[MAX_PATH];

							   // Get the path of the selected file.
							   if (CommDlg_OpenSave_GetFilePath(GetParent(hDlg),
								   szFile, sizeof(szFile)) <= sizeof(szFile))
							   {
								   strcpy(intrProcStr2, szFile);
							   }
							   if (CommDlg_OpenSave_GetFolderPath(GetParent(hDlg), szFile, sizeof(szFile))
								   <= sizeof(szFile)) {
								   strcpy(intrProcStr1, szFile);
							   }
	}
		break;
	}

	return TRUE;
}



// ------------------------------------------------
// 
//  FUNCTION: GetPlugInFullName( char *PlugInFullName)
//
//  PURPOSE:  Gets full path for WIN32API.4dx file.
//
//  COMMENTS: Needed to determine where to look for extra resources
//						Open file dialog etc  
//						     
//	DATE: dcc 07/27/01
//
void GetPlugInFullName(char *PlugInFullName)
{
	// MWD 10/21/05 #9246
	// Use path name to 4DX obtained from entry point as opposed to Client/Server differentiation scheme.

	//char		tmpString[255];
	//check for client or stand-alone
	/*
	if ( PA_Is4DClient() ) {
	// get 4d folder, append structure name, append win4dx\Win32API.4dx
	PA_Get4Dfolder(PlugInFullName);
	PA_GetStructureName(tmpString);
	strcat(PlugInFullName, tmpString);
	strcat(PlugInFullName, "\\win4dx\\win32api.4dx");
	} else {
	PA_GetStructureFullPath(PlugInFullName);
	strcat(PlugInFullName, "win4dx\\win32api.4dx");
	}
	*/
	strcpy(PlugInFullName, pathName);
	return;
}

//  RETAIN FOR DEBUGGING
//  FUNCTION: ProcessCDError(DWORD) 
//
//  PURPOSE: Processes errors from the common dialog functions.
//
//  COMMENTS:
//
//        This function is called whenever a common dialog function
//        fails.  The CommonDialogExtendedError() value is passed to
//        the function which maps the error value to a string table.
//        The string is loaded and displayed for the user. 

void ProcessCDError(DWORD dwErrorCode, HWND hWnd)
{
	WORD			wStringID;
	TCHAR			buf[MAX_PATH];
	HMODULE		hMod;
	char			plugInPath[255];

	GetPlugInFullName(plugInPath);
	hMod = GetModuleHandle(plugInPath);
	switch (dwErrorCode)
	{
	case CDERR_DIALOGFAILURE:   wStringID = IDS_DIALOGFAILURE;   break;
	case CDERR_STRUCTSIZE:      wStringID = IDS_STRUCTSIZE;      break;
	case CDERR_INITIALIZATION:  wStringID = IDS_INITIALIZATION;  break;
	case CDERR_NOTEMPLATE:      wStringID = IDS_NOTEMPLATE;      break;
	case CDERR_NOHINSTANCE:     wStringID = IDS_NOHINSTANCE;     break;
	case CDERR_LOADSTRFAILURE:  wStringID = IDS_LOADSTRFAILURE;  break;
	case CDERR_FINDRESFAILURE:  wStringID = IDS_FINDRESFAILURE;  break;
	case CDERR_LOADRESFAILURE:  wStringID = IDS_LOADRESFAILURE;  break;
	case CDERR_LOCKRESFAILURE:  wStringID = IDS_LOCKRESFAILURE;  break;
	case CDERR_MEMALLOCFAILURE: wStringID = IDS_MEMALLOCFAILURE; break;
	case CDERR_MEMLOCKFAILURE:  wStringID = IDS_MEMLOCKFAILURE;  break;
	case CDERR_NOHOOK:          wStringID = IDS_NOHOOK;          break;
	case PDERR_SETUPFAILURE:    wStringID = IDS_SETUPFAILURE;    break;
	case PDERR_PARSEFAILURE:    wStringID = IDS_PARSEFAILURE;    break;
	case PDERR_RETDEFFAILURE:   wStringID = IDS_RETDEFFAILURE;   break;
	case PDERR_LOADDRVFAILURE:  wStringID = IDS_LOADDRVFAILURE;  break;
	case PDERR_GETDEVMODEFAIL:  wStringID = IDS_GETDEVMODEFAIL;  break;
	case PDERR_INITFAILURE:     wStringID = IDS_INITFAILURE;     break;
	case PDERR_NODEVICES:       wStringID = IDS_NODEVICES;       break;
	case PDERR_NODEFAULTPRN:    wStringID = IDS_NODEFAULTPRN;    break;
	case PDERR_DNDMMISMATCH:    wStringID = IDS_DNDMMISMATCH;    break;
	case PDERR_CREATEICFAILURE: wStringID = IDS_CREATEICFAILURE; break;
	case PDERR_PRINTERNOTFOUND: wStringID = IDS_PRINTERNOTFOUND; break;
	case CFERR_NOFONTS:         wStringID = IDS_NOFONTS;         break;
	case FNERR_SUBCLASSFAILURE: wStringID = IDS_SUBCLASSFAILURE; break;
	case FNERR_INVALIDFILENAME: wStringID = IDS_INVALIDFILENAME; break;
	case FNERR_BUFFERTOOSMALL:  wStringID = IDS_BUFFERTOOSMALL;  break;

	case 0:   //User may have hit CANCEL or we got a *very* random error
		return;

	default:
		wStringID = IDS_UNKNOWNERROR;
	}

	LoadString(hMod, wStringID, buf, sizeof(buf));
	MessageBox(hWnd, buf, NULL, MB_OK);
	return;
}

void	FormatIP(char *rStr, LPARAM dwIP)
{
	char			addrSegment[4];
	BYTE			firstAddr, secondAddr, thirdAddr, fourthAddr;


	strcpy(rStr, "");
	firstAddr = FIRST_IPADDRESS(dwIP);
	secondAddr = SECOND_IPADDRESS(dwIP);
	thirdAddr = THIRD_IPADDRESS(dwIP);
	fourthAddr = FOURTH_IPADDRESS(dwIP);
	_itoa(fourthAddr, addrSegment, 10);
	strcat(rStr, addrSegment);
	strcat(rStr, ".");
	_itoa(thirdAddr, addrSegment, 10);
	strcat(rStr, addrSegment);
	strcat(rStr, ".");
	_itoa(secondAddr, addrSegment, 10);
	strcat(rStr, addrSegment);
	strcat(rStr, ".");
	_itoa(firstAddr, addrSegment, 10);
	strcat(rStr, addrSegment);

	return;
}


HWND getWindowHandle(char* windowTitle, HWND hWnd)
{
	HWND			MDIhWnd, MainhWnd, ChildhWnd, NexthWnd, returnValue = 0;
	char			WindowName[255];
	char			szClassName[255];
	LONG_PTR			windowTitle_len;

	windowTitle_len = strlen(windowTitle);
	if (IsWindow(hWnd)) {
		NexthWnd = hWnd;
		GetClassName(NexthWnd, szClassName, 255);
		do {
			if (strcmp(_strlwr(szClassName), "mdiclient") == 0) {
				windowHandles.MDIhWnd = NexthWnd;
				MDIhWnd = NexthWnd;
				if (strcmp(_strlwr(windowTitle), "mdi") == 0) {
					return NexthWnd;
				}
				else {
					break;
				}
			}
			MDIhWnd = NexthWnd;
			NexthWnd = GetParent(MDIhWnd);
			GetClassName(NexthWnd, szClassName, 255);
		} while (NexthWnd != NULL);

	}
	else {
		returnValue = 0;
		return returnValue;
	}

	if (IsWindow(MDIhWnd)) {
		// Now if the caller wants the main window the
		// windowTitle will be blank
		if (windowTitle_len == 0) {
			// Get the parent of the MDI Window
			// REB 4/14/11 #25290 If we already have the main window handle make sure
			// we use it.
			if (IsWindow(GetParent(MDIhWnd))){
				MainhWnd = GetParent(MDIhWnd);
			}
			else{
				MainhWnd = MDIhWnd;
			}

			if (IsWindow(MainhWnd)) {
				returnValue = MainhWnd;
				return returnValue;
			}
			else {
				returnValue = 0;
				return returnValue;
			}
		}
		else {
			// Search all the child windows for the window 
			// with a Title matching windowTitle
			NexthWnd = GetWindow(MDIhWnd, GW_CHILD);
			do {
				ChildhWnd = NexthWnd;
				if (IsChild(MDIhWnd, ChildhWnd)) {
					GetWindowText(ChildhWnd, WindowName, 256);
					GetClassName(ChildhWnd, szClassName, 255);
					if ((strcmp(_strlwr(szClassName), "mdiclient") == 0) && (strcmp(_strlwr(windowTitle), "mdi") == 0)){
						return ChildhWnd;
					}
					NexthWnd = GetNextWindow(ChildhWnd, GW_HWNDNEXT);
				}
				else {
					returnValue = 0;
					return returnValue;
				}
			} while (strcmp(_strlwr(windowTitle), _strlwr(WindowName)) != 0);
			// Match found
			returnValue = ChildhWnd;
		}
	}
	else {
		returnValue = 0;
	}
	return returnValue;
}


//  FUNCTION: newProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept procedure for 4D window
//
//  COMMENTS:	Used with sys_GetPrintJob and gui_SetTrayIcon functions
//
//	DATE:		dcc 11/17/01

LRESULT APIENTRY newProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HWND					printWndHndl = NULL, childhWnd = NULL, nexthWnd = NULL;
	LONG_PTR					command; // 01/22/03
	static LONG_PTR		count = 1;
	char					windowName[255];
	char					dlgCaption[15];

	switch (uMsg)
	{

	case (WM_USER + 0x0021) :
		if ((lParam == WM_LBUTTONDOWN) || (lParam == WM_RBUTTONDOWN) || (lParam == WM_LBUTTONDBLCLK) || (lParam == WM_RBUTTONDBLCLK)) {

			processWindowMessage(TRAY_ICON_FUNCTION, (LONG_PTR)hwnd, wParam, lParam);
		}
		break;
		// 01/22/03 added check for maximize
	case WM_SYSCOMMAND: //this tells a subsequent WM_GETMINMAXINFO command
		// that it is okay to proceed if we are in the process of a maximize command.
		if (toolBarRestrictions.toolBarOnDeck) {
			command = wParam & 0xFFF0;
			if ((SC_MAXIMIZE == command) || (SC_SIZE == command) || (SC_RESTORE == command)) {
				//get frontmost window
				childhWnd = GetTopWindow(windowHandles.MDIhWnd);
				if (IsZoomed(childhWnd)) {
					switch (command)
					{
					case SC_MAXIMIZE:
						toolBarRestrictions.appBeingMaxed = APP_MAXIMIZING;
						break;

					case SC_RESTORE:
						toolBarRestrictions.appBeingMaxed = APP_RESTORING;
						//ShowWindowAsync (childhWnd, SW_SHOWMAXIMIZED);
						break;

					case SC_SIZE:
						toolBarRestrictions.appBeingMaxed = APP_SIZING_W_CHLDMAX;
						if (IsZoomed(windowHandles.fourDhWnd)) {
							toolBarRestrictions.appWindowState = APP_MAXIMIZED;
						}
						else {
							toolBarRestrictions.appWindowState = APP_NORM;
						}
						//PostMessage(childhWnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
						break;

					}
					//command = (LONG_PTR)childhWnd;
					//command *= -1;
				}
				else {
					processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, command, 0L, 0L);
				}
			}
		}
		break;

	case WM_EXITSIZEMOVE: // 01/27/03
		if (toolBarRestrictions.appBeingMaxed == APP_SIZING_W_CHLDMAX) {
			toolBarRestrictions.appBeingMaxed = 0;
			processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, WM_EXITSIZEMOVE, 0L, 0L);
		}
		break;

	case WM_SIZE:
		if ((toolBarRestrictions.appBeingMaxed == APP_MAXIMIZING) || (toolBarRestrictions.appBeingMaxed == APP_RESTORING)) {
			processWindowMessage(RESPECT_TOOL_BAR_FUNCTION, toolBarRestrictions.appBeingMaxed, 0L, 0L);
		}
		break;
	default:
		// g_intrProcMsg will be PS_IDLE unless print dialogs have been requested
		if ((g_intrProcMsg != PS_IDLE) && (count % 5 == 0) && (g_intrProcMsg < 2)) {
			if (g_intrProcMsg == 0) { // 12/12/01
				strcpy(dlgCaption, "Print Setup");
			}
			else {
				strcpy(dlgCaption, "Print");
			}
			if ((g_intrProcMsg == 0) || ((g_intrProcMsg == 1) && (strcmp(dlgCaption, "Print") == 0))) {
				nexthWnd = GetWindow(hwnd, GW_HWNDPREV);
				do {
					childhWnd = nexthWnd;
					GetWindowText(childhWnd, windowName, 256);
					if (strcmp("Print", windowName) == 0){  // AMS2 11/19/14 #40697 Fixed detection of Print Job window, previously the method assumed that it would always see Print Setup before Print Job. 
						strcpy(dlgCaption, "Print");
						g_intrProcMsg = 1;
					}
					nexthWnd = GetNextWindow(childhWnd, GW_HWNDPREV);
					if (nexthWnd == NULL) {
						count += 1;
						return CallWindowProc(processHandles.wpFourDOrigProc, hwnd, uMsg, wParam, lParam);
					}
				} while (strcmp(dlgCaption, windowName) != 0);
				// Match found
				printWndHndl = childhWnd;

				if (printWndHndl > 0) {
					strcpy(dlgCaption, "Print");
					g_intrProcMsg += 1;
					switch (g_intrProcMsg)
					{
					case 1:
						windowHandles.prthWnd = 0;
						// REB 3/18/11 #25290
						processHandles.wpPrintSettingsDlgOrigProc = (WNDPROC)SetWindowLongPtr(printWndHndl, DWLP_DLGPROC, (LONG_PTR)newPrtSettingsDlgProc);
						//processHandles.wpPrintSettingsDlgOrigProc = (WNDPROC) SetWindowLong(printWndHndl, DWL_DLGPROC, (LONG) newPrtSettingsDlgProc);
						windowHandles.prtSettingshWnd = printWndHndl;
						break;

					case 2:
						// REB 3/18/11 #25290
						processHandles.wpPrintDlgOrigProc = (WNDPROC)SetWindowLongPtr(printWndHndl, DWLP_DLGPROC, (LONG_PTR)newPrtDlgProc);
						//processHandles.wpPrintDlgOrigProc = (WNDPROC) SetWindowLong(printWndHndl, DWL_DLGPROC, (LONG) newPrtDlgProc);
						//restoreOrig4DWindowProcess(); // 01/21/03 // MJG 3/26/04 The 4D window will remain subclassed until the plug-in is unloaded.
						//if (activeCalls.bTrayIcons == FALSE) {
						//SetWindowLong(windowHandles.fourDhWnd, GWL_WNDPROC, (LONG) processHandles.wpFourDOrigProc);
						//}
						windowHandles.prthWnd = printWndHndl;
						break;
					} // end switch
				} //(printWndHndl > 0)
			} //((g_intrProcMsg == 1) && (strcmp(dlgCaption, "Print") == 0))
		} //((count % 10 == 0) && (g_intrProcMsg < 2)) 

		count += 1;
	} // end switch

	return CallWindowProc(processHandles.wpFourDOrigProc, hwnd, uMsg, wParam, lParam);

}


//  FUNCTION: newDlgPrtSettingsProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept print setup dialog 
//
//  COMMENTS:	
//
//	DATE:			dcc 11/17/01

LRESULT APIENTRY newPrtSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	if (hookHandles.printSettingsHookHndl == NULL) {
		hookHandles.printSettingsHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC)printSettingsDlgHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
	}
	return CallWindowProc(processHandles.wpPrintSettingsDlgOrigProc, hwnd, uMsg, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: printSettingsDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Get change of printer if combo box accessed
//
//	DATE:			dcc 11/17/01
//
LRESULT CALLBACK printSettingsDlgHook(INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{
	CWPRETSTRUCT	*cwrps = (CWPRETSTRUCT*)lParam;

	if (cwrps->message == WM_COMMAND) {
		EnumChildWindows(windowHandles.prtSettingshWnd, EnumChildProc2, (LPARAM)PS_PRTSETTINGSDLG);
	}
	return CallNextHookEx(hookHandles.printSettingsHookHndl, hCode, wParam, lParam);
}


//  FUNCTION: newPrtDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
//
//  PURPOSE:	Intercept print dialog 
//
//  COMMENTS:	
//
//	DATE:			dcc 11/17/01

LRESULT APIENTRY newPrtDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

	if (hookHandles.printHookHndl == NULL) {
		UnhookWindowsHookEx(hookHandles.printSettingsHookHndl);
		hookHandles.printSettingsHookHndl = NULL;
		hookHandles.printHookHndl = SetWindowsHookEx(WH_CALLWNDPROCRET, (HOOKPROC)printDlgHook, (HINSTANCE)NULL, (DWORD)GetCurrentThreadId());
	}
	return CallWindowProc(processHandles.wpPrintDlgOrigProc, hwnd, uMsg, wParam, lParam);
}


// ------------------------------------------------
// 
//  FUNCTION: printDlgHook( INT_PTR hCode, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:	Get change of printer if combo box accessed
//
//	DATE:			dcc 11/17/01
//
LRESULT CALLBACK printDlgHook(INT_PTR hCode, WPARAM wParam, LPARAM lParam)
{

	CWPRETSTRUCT	*cwrps = (CWPRETSTRUCT*)lParam;

	if (cwrps->message == WM_COMMAND) {
		EnumChildWindows(windowHandles.prthWnd, EnumChildProc2, (LPARAM)PS_PRTDLG);
	}

	return CallNextHookEx(hookHandles.printHookHndl, hCode, wParam, lParam);
}

// ------------------------------------------------
// 
//  FUNCTION: CALLBACK EnumChildProc2(HWND hWnd, LPARAM lParam)
//
//  PURPOSE:	Find combo box ID with printer names
//
//  COMMENTS: Possible chg this later to constant control ID of 1136
//						
//	DATE:			dcc 10/23/01
//
//  MODIFICATIONS: 11/05/02 Added ID var to better debug.  Also added control ID 1136 for 
//									comboBox on PrintSettings dialog. (3.5.2)
BOOL CALLBACK EnumChildProc2(HWND hWnd, LPARAM lParam)
{
	char						szClassName[255];
	char						comboText[80];
	char						printerName[255];
	LPCTSTR						capabilities[255];
	LONG_PTR						comboText_len = strlen(comboText), ID;
	LRESULT						ndx;
	BOOL						bTrans = FALSE, bSigned = FALSE;
	DEVMODE						*printerInfo;
	DEVMODE						*printInput;
	LPCTSTR						deviceName, pPort;
	LPBYTE						printerBuffer;
	PRINTER_INFO_2				*pInfo;
	HANDLE						hPrintHandle = NULL;
	DWORD						dwPrinterSize;
	DWORD						dwLevel = 2;
	DWORD						dwBuffer = sizeof(PRINTER_INFO_2);

	GetClassName(hWnd, szClassName, 255);

	if (strcmp(_strlwr(szClassName), "combobox") == 0) {
		ID = GetDlgCtrlID(hWnd);
		switch (ID)
		{
		case ID_CB_PRINTER:
		case 1136:
			ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
			SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.printerSelection);
			break;
		case ID_CB_PAPERSIZE:
			ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
			SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.size);
			break;
		case ID_CB_SOURCE:
			ndx = SendMessage(hWnd, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
			SendMessage(hWnd, CB_GETLBTEXT, (WPARAM)ndx, (LPARAM)printerSettings.source);
			break;
		}
	}
	if (strcmp(_strlwr(szClassName), "button") == 0) {
		ID = GetDlgCtrlID(hWnd);

		switch (ID)
		{
		case ID_BTN_PORTRAIT:
			if (lParam == PS_PRTSETTINGSDLG) {
				if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
					printerSettings.portraitLandscape = PS_PORTRAIT;
				}
				else {
					printerSettings.portraitLandscape = PS_LANDSCAPE;
				}
			}
			break;

		case ID_BTN_PRINTTOFILE:
			if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
				printerSettings.printToFile = TRUE;
			}
			else {
				printerSettings.printToFile = FALSE;
			}
			break;
		case ID_BTN_PRINTPREVIEW:
			if (SendMessage(hWnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0) == BST_CHECKED) {
				printerSettings.printPreview = TRUE;
			}
			else {
				printerSettings.printPreview = FALSE;
			}
			break;

		}
	}
	if (strcmp(_strlwr(szClassName), "edit") == 0) {
		// REB 5/13/08 #16829 Storing control ID in ID now.
		ID = GetDlgCtrlID(hWnd);
		switch (ID)
		{
		case ID_EDIT_COPIES:
			ndx = SendMessage(hWnd, WM_GETTEXT, (WPARAM)4, (LPARAM)printerSettings.copies);
			printerSettings.copies[ndx] = '\0';
			break;

		}
	}

	// AMS2 11/26/14 #40697 Below is an attempt to get the printer information that is not visible on the print job dialog with the scanner above.
	// The part that is causing problems is the call to DocumentProperties. I'm not sure if that is the correct window handle to pass in, but the printer handle/device name and other parameters seem to be correct.
	// The issue is that the printerInfo that is returned does not match the settings that are input. I attempted to move this to sys_getPrintSettings but the PA parameter for the return array seemed to be replaced with a null address instead of the array's address. 
	/*
	if (strlen(printerSettings.printerSelection) != 0){

	strcpy(printerName, printerSettings.printerSelection);
	OpenPrinter(printerName, &hPrintHandle, NULL); // get the handle
	//printerBuffer = &pInfo;
	LONG result = GetPrinter(hPrintHandle, dwLevel, NULL, 0, &dwPrinterSize); // get the info for the printer

	PRINTER_INFO_2	*pInfo = (PRINTER_INFO_2*)malloc(dwPrinterSize);
	GetPrinter(hPrintHandle, 2, (LPBYTE)pInfo, dwPrinterSize, &dwPrinterSize);

	deviceName = pInfo->pPrinterName;
	pPort = pInfo->pPortName;
	//DeviceCapabilities(deviceName, pPort, DC_SIZE, capabilities, NULL);
	//DocumentProperties(hWnd, hPrintHandle, deviceName, printerInfo, printInput, DM_OUT_BUFFER); //windowHandles.prthWnd
	ClosePrinter(hPrintHandle);

	}
	*/
	return TRUE;
}

// ------------------------------------------------
// 
//  FUNCTION: enumPrintersUsingRegistry( PA_Variable *printerArray )
//
//  PURPOSE:	Alternative function for enum printers
//
//  COMMENTS: Uses registry for NT/2000/XP 
//						Returns positon of default printer in array
//						
//	DATE:			dcc 04/20/02
//

LONG_PTR enumPrintersUsingRegistry(PA_Variable *printerArray)
{
	LONG_PTR					returnValue = 0, errorCode;
	HKEY					hKeyWindows, hKeyDevices, rootKey;
	char					subKey[100];
	DWORD					dwIndex = 0;
	DWORD					dwType = REG_SZ;
	DWORD					resultSize = 150, dataSize = 150;
	char					sz[150], szData[150], defPrinter[150];

	// get default printer
	strcpy(subKey, "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows");

	rootKey = HKEY_CURRENT_USER; //HKEY_LOCAL_MACHINE;
	hKeyWindows = HKEY_CURRENT_USER; // will get new handle of open key
	hKeyDevices = HKEY_CURRENT_USER;
	errorCode = RegOpenKeyEx(rootKey, subKey, 0, KEY_READ, &hKeyWindows);
	if (errorCode != ERROR_SUCCESS) {
		return returnValue;;
	}

	errorCode = RegQueryValueEx(hKeyWindows, "Device", NULL, &dwType, szData, &resultSize);
	if (errorCode != ERROR_SUCCESS) {
	}
	else {
		strcpy(defPrinter, szData);
	} //(errorCode != ERROR_SUCCESS) 
	errorCode = RegCloseKey(hKeyWindows);

	strcpy(subKey, "Software\\Microsoft\\Windows NT\\CurrentVersion\\Devices");
	errorCode = RegOpenKeyEx(rootKey, subKey, 0, KEY_READ, &hKeyDevices);
	if (errorCode != ERROR_SUCCESS) {
		return returnValue;;
	}
	resultSize = 150;
	errorCode = RegEnumValue(hKeyDevices, dwIndex, sz, &resultSize, NULL, &dwType, szData, &dataSize);
	while (errorCode != ERROR_NO_MORE_ITEMS)
	{
		if (errorCode == ERROR_SUCCESS) {
			// get data for device (printer)	
			PA_ResizeArray(printerArray, (LONG_PTR)dwIndex + 1);
			strcat(sz, ",");
			strcat(sz, szData);
			if (strcmp(sz, defPrinter) == 0) {
				returnValue = dwIndex + 1;
			}
			PA_SetTextInArray(*printerArray, dwIndex + 1, sz, strlen(sz));
		}
		dwIndex++;
		resultSize = 150;
		dataSize = 150;
		errorCode = RegEnumValue(hKeyDevices, dwIndex, sz, &resultSize, NULL, &dwType, szData, &dataSize);
	}

	errorCode = RegCloseKey(hKeyDevices);
	return returnValue;
}

// ------------------------------------------------
// 
//  FUNCTION: enumPrintersUsingINI( PA_Variable *printerArray )
//
//  PURPOSE:	Alternative function for enum printers
//
//  COMMENTS: Uses Win.ini file for 95/98/Me
//						Returns positon of default printer in array
//						
//	DATE:			dcc 04/20/02
//

LONG_PTR enumPrintersUsingINI(PA_Variable *printerArray)
{
	LONG_PTR					returnValue = 0, count = 0, pSectionBuf_len = 0;
	char					szSectionName[80], szKeyName[80], szDefault[80];
	char					defPrinter[80], szSectionBuf[1000], szDevice[80], sep[3]; // increased sep from 2 to 3
	char					*pToken = NULL, *pSectionBuf = NULL;
	DWORD					dwSize = 80, dwReturn;


	// get default printer
	strcpy(szSectionName, "Windows");
	strcpy(szKeyName, "Device");
	dwReturn = GetProfileString(szSectionName, szKeyName, szDefault, defPrinter, dwSize);

	//now get all printers registered
	strcpy(szSectionName, "Devices");
	dwSize = 1000;

	dwReturn = GetProfileSection(szSectionName, szSectionBuf, dwSize);
	strcpy(sep, ",=");
	pSectionBuf = szSectionBuf;
	pToken = strtok(szSectionBuf, sep);
	pSectionBuf = pToken;
	strcpy(szDevice, "");
	count = 0;
	while (pToken != NULL)
	{
		if (szDevice[0] == '\0') {
			strcpy(szDevice, pToken);
			count++;
		}
		else {
			strcat(szDevice, ",");
			strcat(szDevice, pToken);
		}
		pToken = strtok(NULL, sep);
		// write info to array and then look for next device
		if (pToken == NULL) {
			if (strcmp(szDevice, defPrinter) == 0) {
				returnValue = count;
			}
			PA_ResizeArray(printerArray, count);
			PA_SetTextInArray(*printerArray, count, szDevice, strlen(szDevice));
			pSectionBuf_len = strlen(pSectionBuf);
			pSectionBuf = pSectionBuf + (pSectionBuf_len + 1);
			if (*pSectionBuf != '\0') {
				strcpy(szDevice, "");
				pToken = strtok(pSectionBuf, sep);
			}
		}
		else {
			pSectionBuf = pToken;
		}
	}
	return returnValue;
}




// ------------------------------------------------
// 
//  FUNCTION: sys_GetTimeZoneList( PA_PluginParameters params )
//
//  PURPOSE:  Returns an array containing time zone information for all time zones
//				defined on the system.  Each element is in the form:
//				TimeZoneName;Current Time;Current Date
//  
//
//  REB 4/6/09 #19472  
//



void sys_GetTimeZoneList(PA_PluginParameters params)
{
	PA_Variable		atTZ;
	char			standardName[255];
	char			daylightName[255];
	char			displayName[255];
	LONG_PTR			displayName_len;
	LONG_PTR			returnValue, errorCode;
	HKEY			hkTimeZone, hkRootKey;
	char			TimeStr[255];
	char			hours[2];
	char			mins[2];
	char			secs[2];
	char			DateStr[255];
	char			month[2];
	char			day[2];
	char			year[10];
	char			TZ[512];
	DWORD			dwSubKeys, dwValues, dwDataSize;
	REG_TZI_FORMAT	TZInfoFormat;
	DWORD			index = 1;
	char			rootTimeZoneKey[60] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones";
	DWORD			dwIndex = 0;
	TCHAR			tcKeyName[512];
	DWORD			dwcbName = 512 * sizeof(TCHAR);
	FILETIME		ftLastWrite;
	TIME_ZONE_INFORMATION TimeZoneInformation;
	SYSTEMTIME		SystemTimeNow, LocalTime;

	// For some reason we are unable to return 3 arrays to 4D.  Instead we'll return
	// a single array with all three data items in semicolon delimited elements.

	atTZ = PA_GetVariableParameter(params, 1);
	PA_ResizeArray(&atTZ, 0);

	returnValue = -1; // Assume we fail, this is set to the number of time zones once we successfully open the root TZ key.

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, rootTimeZoneKey, 0, KEY_READ, &hkRootKey) == ERROR_SUCCESS)
	{
		if (RegQueryInfoKey(hkRootKey, NULL, NULL, NULL, &dwSubKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
		{
			PA_ResizeArray(&atTZ, dwSubKeys);

			returnValue = dwSubKeys; // Return the number of time zones we've found.

			while (RegEnumKeyEx(hkRootKey, dwIndex++, tcKeyName, &dwcbName, NULL, NULL, NULL, &ftLastWrite) != ERROR_NO_MORE_ITEMS)
			{
				if (RegOpenKeyEx(hkRootKey, tcKeyName, 0, KEY_READ, &hkTimeZone) == ERROR_SUCCESS)
				{
					// Get TZI Upper Bytes
					dwDataSize = sizeof(TZInfoFormat);
					errorCode = RegQueryValueEx(hkTimeZone, "TZI", NULL, NULL, (BYTE*)&TZInfoFormat, &dwDataSize);

					TimeZoneInformation.Bias = TZInfoFormat.Bias;
					TimeZoneInformation.DaylightBias = TZInfoFormat.DaylightBias;
					TimeZoneInformation.DaylightDate = TZInfoFormat.DaylightDate;
					TimeZoneInformation.StandardBias = TZInfoFormat.StandardBias;
					TimeZoneInformation.StandardDate = TZInfoFormat.StandardDate;

					// Get Text Values
					dwDataSize = 255;
					if (RegQueryValueEx(hkTimeZone, "Display", NULL, NULL, (LPBYTE)&displayName, &dwDataSize) != ERROR_SUCCESS)
					{
						strcpy(displayName, "n/a");
					}
					displayName_len = strlen(displayName);

					strcpy(TZ, displayName);

					dwDataSize = 255;
					if (RegQueryValueEx(hkTimeZone, "Dlt", NULL, NULL, (LPBYTE)&daylightName, &dwDataSize) != ERROR_SUCCESS)
					{
						strcpy(daylightName, "n/a");
					}

					mbstowcs(TimeZoneInformation.DaylightName, daylightName, dwDataSize);

					dwDataSize = 255;
					if (RegQueryValueEx(hkTimeZone, "Std", NULL, NULL, (LPBYTE)&standardName, &dwDataSize) != ERROR_SUCCESS)
					{
						strcpy(standardName, "n/a");
					}
					mbstowcs(TimeZoneInformation.StandardName, standardName, dwDataSize);

					RegCloseKey(hkTimeZone);

					// Get the current time in UTC
					GetSystemTime(&SystemTimeNow);

					// Get the current time in the specified time zone.
					SystemTimeToTzSpecificLocalTime(&TimeZoneInformation, &SystemTimeNow, &LocalTime);

					_itoa(LocalTime.wHour, hours, 10);
					_itoa(LocalTime.wMinute, mins, 10);
					_itoa(LocalTime.wSecond, secs, 10);

					strcpy(TimeStr, hours);
					strcat(TimeStr, ":");
					strcat(TimeStr, mins);
					strcat(TimeStr, ":");
					strcat(TimeStr, secs);

					strcat(TZ, ";");
					strcat(TZ, TimeStr);

					_itoa(LocalTime.wDay, day, 10);
					_itoa(LocalTime.wMonth, month, 10);
					_itoa(LocalTime.wYear, year, 10);

					strcpy(DateStr, month);
					strcat(DateStr, "/");
					strcat(DateStr, day);
					strcat(DateStr, "/");
					strcat(DateStr, year);

					strcat(TZ, ";");
					strcat(TZ, DateStr);

					strcpy(TZ, displayName);
					strcat(TZ, ";");
					strcat(TZ, TimeStr);
					strcat(TZ, ";");
					strcat(TZ, DateStr);

					PA_SetTextInArray(atTZ, index, TZ, strlen(TZ));
				}
				dwcbName = 512 * sizeof(TCHAR);
				++index;
			}
		}
		RegCloseKey(hkRootKey);

	}

	PA_SetVariableParameter(params, 1, atTZ, 0);

	PA_ReturnLong(params, returnValue);

}


// Note, this does not need to use the semaphore since it is already waiting on a file
void TWAIN_GetSources(PA_PluginParameters params)
{

	LONG_PTR			returnValue, OK, state, debug;
	DWORD				index = 1;
	PA_Variable			atSources;
	// TW_IDENTITY			NewSourceId; // WJF 9/14/15 #43727 Removed
	char				lpParameters[16] = "-S"; // WJF 9/21/15 #43940 3 -> 16
	char				filePath[MAX_PATH] = "";
	BOOL				get64 = FALSE;
	FILE				*fp = NULL;
	char				source[256] = ""; 
	char				pluginPath[MAX_PATH] = "";
	char				*pos = NULL;

	atSources = PA_GetVariableParameter(params, 1);
	PA_ResizeArray(&atSources, 0);

	debug = PA_GetLongParameter(params, 2); 

	get64 = PA_GetLongParameter(params, 3);

	returnValue = 1;

	// WJF 9/11/15 #43727 Begin changes

	strcpy_s(pluginPath, MAX_PATH, pathName);

	pos = strrchr(pluginPath, '\\');

	strcpy(pos, "\0");

	pos = strrchr(pluginPath, '\\');

	strcpy(pos, "\\\0");

	// WJF 9/21/15 #43940 OrchardTwain -> Orchard_Utilities
	if (get64){
		strcpy_s(pos, MAX_PATH, "\\Windows64\\Orchard_Utilities.exe");
	}
	else {
		strcpy_s(pos, MAX_PATH, "\\Windows\\Orchard_Utilities.exe");
	}
		
	GetTempPath(MAX_PATH, filePath);

	strcat_s(filePath, MAX_PATH, "twainSources.txt");

	utilitiesLock(); // WJF 9/21/15 #43940

	ShellExecute(windowHandles.fourDhWnd, "", pluginPath, lpParameters, NULL, SW_HIDE);

	if (GetLastError() == ERROR_SUCCESS){
		PA_YieldAbsolute();
		PA_YieldAbsolute();
		PA_YieldAbsolute();

		utilitiesYield(NULL); // WJF 9/21/15 #43940 Moved to common method

		fp = fopen(filePath, "r");

		if (fp){
			while (fgets(source, 256, fp) != NULL){
				if (strcmp(source, "-1") == 0){ // Failed to load Twain library
					returnValue = -1;
				}
				else if (strcmp(source, "-2") == 0){ // Failed to open Data Source Manager
					returnValue = -2;
				}
				else if (strcmp(source, "") == 0){ // Empty line
					// do nothing
				}
				else { // Valid Product Name
					pos = strrchr(source, '\n');
					strcpy_s(pos, 256, "\0");
					strcat_s(source, 256, "-TWAIN"); // WJF 9/21/15 #43940
					PA_ResizeArray(&atSources, index);
					PA_SetTextInArray(atSources, index, source, strlen(source));
					++index;
				}

			}

			fclose(fp);

			fp = NULL;

			DeleteFile(filePath);

			// WJF 9/21/15 #43940 Begin Changes
			GetTempPath(MAX_PATH, filePath);

			strcat_s(filePath, MAX_PATH, "wiaSources.txt");

			strcpy_s(lpParameters, 16, "-ws");

			utilitiesLock();

			ShellExecute(windowHandles.fourDhWnd, "", pluginPath, lpParameters, NULL, SW_HIDE);

			if (GetLastError() == ERROR_SUCCESS){
				PA_YieldAbsolute();
				PA_YieldAbsolute();
				PA_YieldAbsolute();

				utilitiesYield(NULL); // WJF 9/21/15 #43601 Moved to common method

				fp = fopen(filePath, "r");

				if (fp){
					while (fgets(source, 256, fp) != NULL){
						if (strcmp(source, "") != 0){
							pos = strrchr(source, '\n');
							strcpy_s(pos, 256, "\0");
							strcat_s(source, 256, "-WIA");
							PA_ResizeArray(&atSources, index);
							PA_SetTextInArray(atSources, index, source, strlen(source));
							++index;
						}

					}

					fclose(fp);

					fp = NULL;
				}

				DeleteFile(filePath); // WJF 9/21/15 #43940
			}
			else {
				returnValue = -1;
			}
			// WJF 9/21/15 #43940 End changes
		}
		else {
			returnValue = -2; // WJF 9/21/15 #43940 0 -> -2
		}
	}
	// Removed
	/*if (debug) returnValue = TWAIN_SelectImageSource(windowHandles.fourDhWnd);

	memset(&NewSourceId, 0, sizeof NewSourceId);

	state = TWAIN_State();

	if (state >= TWAIN_SM_OPEN || TWAIN_OpenSourceManager(windowHandles.fourDhWnd)) {
		OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETFIRST, &NewSourceId);
		if (!(debug)){
			returnValue = OK;
		}
		while (OK){
			PA_ResizeArray(&atSources, index);
			PA_SetTextInArray(atSources, index, NewSourceId.ProductName, strlen(NewSourceId.ProductName));
			++index;
			OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETNEXT, &NewSourceId);
		}
	}
	*/
	// WJF 9/11/15 #43727 End changes

	PA_SetVariableParameter(params, 1, atSources, 0);
	PA_ReturnLong(params, returnValue);
}


void TWAIN_SetSource(PA_PluginParameters params)
{
	LONG_PTR			returnValue, OK;
	LONG_PTR			source_len;
	char			sourceName[255];

	source_len = PA_GetTextParameter(params, 1, sourceName);
	sourceName[source_len] = '\0';

	returnValue = 1;

	// WJF 9/11/15 #43727 Begin changes
	if (twainSource){ // If we've already set a source, clear it
		free(twainSource);

		twainSource = NULL;
	}

	twainSource = (char *)malloc(source_len + 1);

	// WJF 9/29/15 Added a check to see if it was actually allocated and a new error code
	if (twainSource){
		strcpy_s(twainSource, source_len + 1, sourceName);
	}
	else { 
		returnValue = 0;
	}

	// Removed
	/* 
	memset(&NewSourceId, 0, sizeof NewSourceId);

	// If the source is already open, close it to reset the connection.
	state = TWAIN_State();
	if (state >= TWAIN_SOURCE_ENABLED){
		OK = TWAIN_EndXfer();
		OK = TWAIN_AbortAllPendingXfers();
		OK = TWAIN_CloseSource();
	}

	if (state >= TWAIN_SM_OPEN || TWAIN_OpenSourceManager(windowHandles.fourDhWnd)) {
		OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETFIRST, &NewSourceId);
		while (OK){
			if (strcmp(sourceName, NewSourceId.ProductName) == 0){
				OK = 0;
				returnValue = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_OPENDS, &NewSourceId);
			}
			else{
				OK = TWAIN_Mgr(DG_CONTROL, DAT_IDENTITY, MSG_GETNEXT, &NewSourceId);
			}
		}
	} */
	// WJF 9/1/15 #43727 End changes

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	OrchTwain_Get(LPCSTR filePath, BOOL Get64)
//
//  PURPOSE:	Launches the external OrchTwain DLL and waits for the operation to finish
//
//  COMMENTS:	
//
//	DATE:		WJF 9/10/15 #43727
long __stdcall OrchTwain_Get(const char * filePath, BOOL Get64, BOOL ShowUI, BOOL IsWIA, BOOL GetMultiple){
	char lpParameters[MAX_PATH_PLUS] = "";
	char filePathLock[MAX_PATH_PLUS] = "";
	char pluginPath[MAX_PATH] = "";
	char *path = NULL;
	char *pos = NULL;
	FILE *fp = NULL;
	long returnValue = 1;
	char sourceName[256] = "";
	
	strcpy_s(pluginPath, MAX_PATH, pathName);

	pos = strrchr(pluginPath, '\\');

	strcpy(pos, "\0");

	pos = strrchr(pluginPath, '\\');

	strcpy(pos, "\\\0");

	if (Get64){
		strcpy_s(pos, MAX_PATH, "\\Windows64\\Orchard_Utilities.exe");
	}
	else {
		strcpy_s(pos, MAX_PATH, "\\Windows\\Orchard_Utilities.exe");
	}
	
	// WJF 9/21/15 #43940
	if (twainSource){
		pos = NULL;
		pos = strstr(twainSource, "-TWAIN");

		if (!pos){
			pos = strstr(twainSource, "-WIA");

			if (pos){
				IsWIA = TRUE;
			}
		}

		// WJF 9/24/15 #43940 
		strcpy_s(sourceName, 256, twainSource); 
		pos = NULL;
		pos = strrchr(sourceName, '-');

		if (pos){
			strcpy_s(pos, MAX_PATH, "\0");
		}
	}
	
	if (IsWIA){ // WJF 9/21/15 #43940
		strcpy_s(lpParameters, MAX_PATH_PLUS, "-wa ");
	}
	else {
		strcpy_s(lpParameters, MAX_PATH_PLUS, "-A ");
	}

	strcat_s(lpParameters, MAX_PATH_PLUS, filePath);

	if (GetMultiple){
		strcat_s(lpParameters, MAX_PATH_PLUS, " 1");
	}
	else {
		strcat_s(lpParameters, MAX_PATH_PLUS, " 0");
	}
	
	if (ShowUI){
		strcat_s(lpParameters, MAX_PATH_PLUS, " 1 ");
	}
	else {
		strcat_s(lpParameters, MAX_PATH_PLUS, " 0 ");
	}

	if (twainSource){
		if (strcmp(sourceName, "") != 0){
			strcat_s(lpParameters, MAX_PATH_PLUS, "\"");
			strcat_s(lpParameters, MAX_PATH_PLUS, sourceName);
			strcat_s(lpParameters, MAX_PATH_PLUS, "\"");
		}
	}

	utilitiesLock(); // WJF 9/21/15 #43601 Moved to common method

	ShellExecute(windowHandles.fourDhWnd, "", pluginPath, lpParameters, NULL, SW_SHOW);

	if (GetLastError() == ERROR_SUCCESS){
		utilitiesSleep(NULL); // WJF 9/21/15 #43601 Moved to common method

		returnValue = 0;
	}

	return returnValue;
}

//  FUNCTION:	utilitiesLock()
//
//  PURPOSE:	Creates the semaphore for the orchard_utilties application
//
//  COMMENTS:	
//
//	DATE:		WJF 9/21/15 #43601
void utilitiesLock(){
	char lockPath[MAX_PATH] = "";
	FILE *fp = NULL;

	GetTempPath(MAX_PATH, lockPath);

	strcat_s(lockPath, MAX_PATH, "utilitiesLock.txt");

	fp = fopen(lockPath, "w");

	if (fp){
		fprintf(fp, "Locked\n");

		fclose(fp);

		fp = NULL;
	}

}

//  FUNCTION:	utilitiesSleep()
//
//  PURPOSE:	Waits until the utilities application semaphore is cleared
//
//  COMMENTS:	Use this when NOT in the main Win32API thread
//
//	DATE:		WJF 9/21/15 #43601
void utilitiesSleep(const char * filePath){
	char lockPath[MAX_PATH] = "";
	
	GetTempPath(MAX_PATH, lockPath);

	strcat_s(lockPath, MAX_PATH, "utilitiesLock.txt");

	SetLastError(ERROR_SUCCESS);

	if (filePath){
		while ((GetFileAttributes(filePath) == INVALID_FILE_ATTRIBUTES) || (GetLastError() == ERROR_FILE_NOT_FOUND)){ // When this file exists, the operation is completed
			Sleep(100);
		}
	}
	else {
		while ((GetFileAttributes(lockPath) != INVALID_FILE_ATTRIBUTES) && (GetLastError() != ERROR_FILE_NOT_FOUND)){ // When this file no longer exists, the operation is completed
			Sleep(100);
		}
	}
}

//  FUNCTION:	utilitiesYield()
//
//  PURPOSE:	Waits until the utilities application semaphore is cleared
//
//  COMMENTS:	Use this when in the main Win32API thread
//
//	DATE:		WJF 9/21/15 #43601
void utilitiesYield(const char * filePath){
	char lockPath[MAX_PATH] = "";

	GetTempPath(MAX_PATH, lockPath);

	strcat_s(lockPath, MAX_PATH, "utilitiesLock.txt");

	SetLastError(ERROR_SUCCESS);

	if (filePath){
		while ((GetFileAttributes(filePath) == INVALID_FILE_ATTRIBUTES) || (GetLastError() == ERROR_FILE_NOT_FOUND)){ // When this file exists, the operation is completed
			PA_YieldAbsolute();
		}
	}
	else {
		while ((GetFileAttributes(lockPath) != INVALID_FILE_ATTRIBUTES) && (GetLastError() != ERROR_FILE_NOT_FOUND)){ // When this file no longer exists, the operation is completed
			PA_YieldAbsolute();
		}
	}
}

// REB 2/26/13 #35165 Intermediary method we can call as a new thread.
unsigned __stdcall TWAIN_GetImage(void *arg)
{
	TWAIN_CAPTURE*	TWAINCapture;
	char			iterator[16] = "";
	char			*pos = NULL;
	BOOL			bContinue = TRUE;
	char			filePath[MAX_PATH] = "";
	long			i = 0;

	TWAINCapture = (TWAIN_CAPTURE*)arg; 
	// WJF 9/10/15 #43727 Removed
	//TWAIN_UnloadSourceManager();  // REB 2/26/13 #35165 We have to reset our source before trying to acquire an image.
	//TWAINCapture->DIBHandle = TWAIN_AcquireNative(NULL, TWAIN_ANYTYPE, &returnValue);

	TWAINCapture->returnValue = OrchTwain_Get(TWAINCapture->filePath, TWAINCapture->get64, TWAINCapture->showUI, TWAINCapture->wiaMode, TWAINCapture->getMultiple); // WJF 9/10/15 #43727 // WJF 9/21/15 #43940
	
	if (TWAINCapture->getMultiple){
		while (bContinue){
			SetLastError(ERROR_SUCCESS);

			i++;

			strcpy_s(filePath, MAX_PATH, TWAINCapture->filePath);

			pos = strrchr(filePath, '.');

			_itoa(i, iterator, 10);

			strcpy_s(pos, MAX_PATH, iterator);

			strcat_s(filePath, MAX_PATH, ".bmp");

			if ((GetFileAttributes(filePath) == INVALID_FILE_ATTRIBUTES) || (GetLastError() == ERROR_FILE_NOT_FOUND)){
				bContinue = FALSE;
				i--;
			}

		}

		TWAINCapture->numPictures = i;
	}

	TWAINCapture->done = TRUE;
	
	return 0;
}

void TWAIN_AcquireImage(PA_PluginParameters params)
{

	LONG_PTR		returnValue = 0, showDialog, threadID;
	char*			charPos;
	char			fileName[255] = "";
	char			fileName2[255] = "";
	char			 *pch = NULL;
	char			command[255] = "";
	char			pathChar[1] = "\\";
	// HANDLE			DIBHandle = NULL; // WJF 9/10/15 #43727 No longer needed
	HANDLE			CaptureThread;
	PA_Unistring	Unistring;
	TWAIN_CAPTURE	TWAINCapture; // REB 2/26/13 #35165
	char			*BLOB = NULL; // AMS 7/3/14 #39391
	LONG_PTR		len = 0; // AMS 7/3/14 #39391
	char			cmdName[256] = ""; // WJF 6/29/15 #42792
	char			cName[256] = ""; // WJF 6/29/15 #42792
	char			pathName[MAX_PATH] = ""; // WJF 9/15/15 #43727 Initialize this value
	char			iterator[16] = ""; // WJF 9/21/15 #43940
	BOOL			x64 = FALSE; // WJF 9/21/15 #43727
	BOOL			wiaMode = FALSE; // WJF 9/21/15 #43940
	BOOL			getMultiple = FALSE; // WJF 9/21/15 #43940
	char			fileName3[255] = ""; // WJF 9/21/15 #43940
	char			cName2[256] = ""; // WJF 9/21/15 #43940
	char			command2[256] = ""; // WJF 9/21/15 #43940

	showDialog = PA_GetLongParameter(params, 1);

	// AMS 7/3/14 #39391 Get the blob parameter // WJF 6/29/15 #42792 Changed BLOB -> Text
	BLOB = NULL;
	len = PA_GetTextParameter(params, 2, NULL);

	if (len > 0) { // WJF 6/29/15 #42792 Don't allocate unless a variable was passed
		BLOB = malloc(len+1); // WJF 6/29/15 #42792 Added +1
		len = PA_GetTextParameter(params, 2, BLOB);
	}

	x64 = PA_GetLongParameter(params, 3); // WJF 9/21/15 #43727

	getMultiple = PA_GetLongParameter(params, 4); // WJF 9/21/15 #43940

	wiaMode = PA_GetLongParameter(params, 5); // WJF 9/21/15 #43940

	//Unistring = PA_GetApplicationFullPath(); // REB 4/20/11 #27322
	//pathName = UnistringToCString(&Unistring); // REB 4/20/11 #27322 #27490 Fixed method call.
//	PA_DisposeUnistring(&Unistring); // WJF 6/29/15 #42792
	GetTempPath(MAX_PATH, pathName);
	charPos = strrchr(pathName, '\\');
	strncpy(fileName, pathName, (charPos - pathName + 1));
	strncat_s(fileName, 255, "TWNIMG.bmp", strlen("TWNIMG.bmp"));

	// Allow the image dialog to display if so desired.
	// WJF 9/10/15 #43727 Changed to use a new variable instead of the EZTWAIN function
	if (showDialog){
		TWAINCapture.showUI = TRUE;
	}
	else{
		TWAINCapture.showUI = FALSE;
	}

	// REB 2/26/13 #35165 Load our variables into the structure we can pass to the new thread
	TWAINCapture.returnValue = 0;
	// TWAINCapture.DIBHandle = DIBHandle; // WJF 9/10/15 #43727 Removed
	TWAINCapture.done = FALSE;

	TWAINCapture.get64 = x64; // WJF 9/10/15 #43727

	TWAINCapture.getMultiple = getMultiple; // WJF 9/21/15 #43940

	TWAINCapture.wiaMode = wiaMode; // WJF 9/21/15 #43940

	TWAINCapture.numPictures = 1; // WJF 9/21/15 #43940 Default
	
	TWAINCapture.filePath = (char *)malloc(MAX_PATH_PLUS); // WJF 9/15/15 #43727

	strcpy_s(TWAINCapture.filePath, MAX_PATH_PLUS, ""); // WJF 9/15/15 #43727

	strncpy_s(TWAINCapture.filePath, MAX_PATH_PLUS, fileName, strlen(fileName)); // WJF 9/10/15 #43727

	//DIBHandle = TWAIN_AcquireNative( windowHandles.fourDhWnd, TWAIN_ANYTYPE, &returnValue);
	// REB 2/26/13 #35165 Start a new thread to handle the image acquisition so that we can yield time
	// back to 4D to prevent an application timeout.
	CaptureThread = (HANDLE)_beginthreadex(NULL, 0, TWAIN_GetImage, &TWAINCapture, 0, &threadID);

	// REB 2/26/13 #35165 4D says to call this at least three times when starting an external process.
	// That's not exactly what we're doing but I'll err on the side of caution.
	PA_YieldAbsolute();
	PA_YieldAbsolute();
	PA_YieldAbsolute();

	// Yield time back to 4D until the capture is finished.
	while (TWAINCapture.done == FALSE){
		PA_YieldAbsolute();
	}

	// REB 2/26/13 #35165 Now get the values from the structure
	//DIBHandle = TWAINCapture.DIBHandle; // WJF 9/10/15 #43727
	returnValue = TWAINCapture.returnValue;


	// Updated so that return code is 1 for success, 0 for cancel and negative for error codes.
	// Suppress eztwain error dialogs
	// WJF 9/10/15 #43727 We are now checking to see if the file exists rather than for a valid DIB handle
	strcpy_s(fileName3, 255, fileName);
	charPos = strrchr(fileName3, '.');
	strcpy_s(charPos, 255, "1");
	strcat_s(fileName3, 255, ".bmp");
	if ((GetFileAttributes(fileName3) != INVALID_FILE_ATTRIBUTES) && (GetLastError() != ERROR_FILE_NOT_FOUND)){
		
		// returnValue = TWAIN_WriteNativeToFilename(DIBHandle, fileName2); // WJF 9/10/15 #43727 Removed

		// TWAIN_WriteNativetoFilename returns 0 on success
		if (returnValue == 0) {

			returnValue = 1;

			strcpy_s(fileName3, 255, fileName); // WJF 9/21/15 #43940 Backup the file name

			if (len == 0) // AMS 7/3/14 #39391 Use PA_ExecuteMethod if no blob was passed in.
			{

				// AMS 7/10/14 #39391 Rewrote this portion of the method to use PA_GetCommandName. This allows users to not have to pass in an extra blob parameter. 

				PA_GetCommandName(525, cmdName);

				int j = 0;

				// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..). 
				// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
				for (int i = 0; i < sizeof(cmdName); i++) // WJF 6/29/15 #43134 Changed <= to <
				{
					if (cmdName[i] != '\0')
					{
						cName[j] = cmdName[i];
						j++;
					}
				}

				cName[(strlen(cName))] = '\0';

				for (int i = 0; i < TWAINCapture.numPictures; i++){// WJF 9/21/15 #43940 
					pch = fileName;

					// WJF 9/21/15 #43940
					strcpy_s(fileName, 255, fileName3);
					charPos = strrchr(fileName, '.');
					_itoa(i+1, iterator, 10);
					strcpy_s(charPos, 255, iterator);
					strcat_s(fileName, 255, ".bmp");
					strcpy_s(fileName2, 255, "");
					
					charPos = strchr(fileName, '\\');
					while (charPos != NULL){
						strncat(fileName2, pch, (charPos - pch));
						pch = charPos;
						charPos = strchr((charPos + 1), '\\');
						if (charPos != NULL){
							strcat(fileName2, "\\");
						}
						else{
							// add the remainder of fileName to fileName2.
							strcat(fileName2, "\\");
							strcat(fileName2, pch);
						}
					}

					if (getMultiple){ // WJF 9/22/15 #43940
						//strcpy(command, "DOCUMENT TO BLOB(\"");
						strncpy(command, cName, sizeof(command));
						strcat(command, "(\"");
						strcat(command, fileName2);
						strcat(command, "\";xTempTWAINBlob)"); 

						Unistring = CStringToUnistring(&command);
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring); 

						PA_GetCommandName(532, cmdName); // VARIABLE TO BLOB

						j = 0;

						// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..). 
						// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
						for (int k = 0; k < sizeof(cmdName); k++)
						{
							if (cmdName[k] != '\0')
							{
								cName2[j] = cmdName[k];
								j++;
							}
						}

						strcpy_s(command2, 255, cName2);
						strcat_s(command2, 255, "(xTempTWAINBlob;xTWAINBlob;*)");

						Unistring = CStringToUnistring(&command2);
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);

					}
					else {
						//strcpy(command, "DOCUMENT TO BLOB(\"");
						strncpy(command, cName, sizeof(command));
						strcat(command, "(\"");
						strcat(command, fileName2);
						strcat(command, "\";xTWAINBLOB)");

						// REB 4/20/11 #27322 Conver the C string to a Unistring
						Unistring = CStringToUnistring(&command);
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring); // WJF 6/25/15 #42792
						//PA_ExecuteMethod(command, strlen(command));
					}

					DeleteFile(fileName); // WJF 9/21/15 #43940 Moved to loop
				}
			}
			else // Leaving this in place just in case a user does not want to use our xTWAINBlob variable
			{ // WJF 6/29/15 #42792 Changed this to be like the above section because of a memory leak with varArray[0]. Now users will have to pass the name of the blob as text.

				PA_GetCommandName(525, cmdName);

				int j = 0;

				// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..). 
				// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
				for (int i = 0; i < sizeof(cmdName); i++) 
				{
					if (cmdName[i] != '\0')
					{
						cName[j] = cmdName[i];
						j++;
					}
				}

				cName[(strlen(cName))] = '\0';

				// WJF 9/21/15 #43940 
				for (int i = 0; i < TWAINCapture.numPictures; i++){
					pch = fileName;

					strcpy_s(fileName, 255, fileName3);
					charPos = strrchr(fileName, '.');
					_itoa(i + 1, iterator, 10);
					strcpy_s(charPos, 255, iterator);
					strcat_s(fileName, 255, ".bmp");
					strcpy_s(fileName2, 255, "");

					charPos = strchr(fileName, '\\');
					while (charPos != NULL){
						strncat(fileName2, pch, (charPos - pch));
						pch = charPos;
						charPos = strchr((charPos + 1), '\\');
						if (charPos != NULL){
							strcat(fileName2, "\\");
						}
						else{
							// add the remainder of fileName to fileName2.
							strcat(fileName2, "\\");
							strcat(fileName2, pch);
						}
					}

					if (getMultiple){ 
						strncpy(command, cName, sizeof(command));
						strcat(command, "(\"");
						strcat(command, fileName2);
						strcat(command, "\";xTempTWAINBlob)");

						Unistring = CStringToUnistring(&command);
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);

						PA_GetCommandName(532, cmdName); // VARIABLE TO BLOB

						j = 0;

						// Get the full command name. A for loop is needed because PA_GetCommandName returns the command name with a null character between each character. (Ex. - "D,\0,O,\0,C,\0..). 
						// The for loop extracts the null character. Without the for loop, you will be unable to use the string returned by PA_GetCommand, as only the first character will be returned since the next character is null.
						for (int k = 0; k < sizeof(cmdName); k++)
						{
							if (cmdName[k] != '\0')
							{
								cName2[j] = cmdName[k];
								j++;
							}
						}

						strcpy_s(command2, 255, cName2);
						strcat_s(command2, 255, "(xTempTWAINBlob;");
						strcat_s(command2, 255, BLOB);
						strcat_s(command2, 255, ";*)");

						Unistring = CStringToUnistring(&command2);
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);

					}
					else {
						strcpy_s(command, 255, cName);
						strcat_s(command, 255, "(\"");
						strcat_s(command, 255, fileName2);
						strcat_s(command, 255, "\";");
						strcat_s(command, 255, BLOB);
						strcat_s(command, 255, ")");

						Unistring = CStringToUnistring(&command);
						PA_ExecuteMethod(&Unistring);
						PA_DisposeUnistring(&Unistring);
					}

					DeleteFile(fileName);
				}

				// WJF 9/22/15 #43940 Removed
				/*strncpy(command, cName, sizeof(command));
				strcat(command, "(\"");
				strcat(command, fileName2);
				strcat(command, "\";");
				strcat(command, BLOB);
				strcat(command, ")");

				Unistring = CStringToUnistring(&command);
				PA_ExecuteMethod(&Unistring);
				PA_DisposeUnistring(&Unistring);*/

				/*PA_Unistring _path = CStringToUnistring(fileName);
				PA_Variable varArray[2];

				varArray[0] = PA_CreateVariable(eVK_Unistring);
				PA_SetStringVariable(&varArray[0], &_path);

				varArray[1] = PA_CreateVariable(eVK_Blob);
				varArray[1].fFiller = 0;

				PA_ExecuteCommandByID(525, varArray, 2);

				char *twainBlob;
				long blobSize;

				blobSize = PA_GetBlobVariable(varArray[1], NULL);
				twainBlob = malloc(blobSize);
				blobSize = PA_GetBlobVariable(varArray[1], twainBlob);

				PA_SetBlobParameter(params, 2, twainBlob, blobSize);

				PA_DisposeUnistring(&Unistring); // WJF 6/25/15 #42792
				free(twainBlob); */
			}
			
		}
	}

	if (len>0) // WJF 6/29/15 #42792 Only free if allocated
	{
		free(BLOB); // AMS 7/10/14 #39391
	}
	
	//free(pathName); // WJF 6/25/15 #42792

	if (TWAINCapture.filePath){
		free(TWAINCapture.filePath);
		TWAINCapture.filePath = NULL;
	}

	PA_ReturnLong(params, returnValue);

	// TWAIN_FreeNative(DIBHandle); // WJF 9/10/15 #43727 No longer needed

}


/***************************************************************
Determine if the frontmost window belongs to our instance
of 4D.

REB 4/6/09 #19472
****************************************************************/
void sys_IsAppFrontmost(PA_PluginParameters params)
{
	HWND			hwndFront;
	HWND			MDIhWnd, ChildhWnd, NexthWnd, returnValue = 0;
	LONG_PTR			lFound = 0;

	// First get the frontmost window.
	hwndFront = GetForegroundWindow();

	MDIhWnd = windowHandles.MDIhWnd; // Assigning to a variable to use later.

	// Now see if the frontmost window is one of ours.

	if (windowHandles.fourDhWnd == hwndFront){
		lFound = 1;
	}
	else if (MDIhWnd == hwndFront){
		lFound = 1;
	}
	else{
		// It's not one of the main windows, check all of our child windows

		NexthWnd = GetWindow(MDIhWnd, GW_CHILD);
		do {
			ChildhWnd = NexthWnd;
			if (IsChild(MDIhWnd, ChildhWnd)) {
				if (hwndFront == ChildhWnd){
					lFound = 1;
					break;
				}
				NexthWnd = GetNextWindow(ChildhWnd, GW_HWNDNEXT);
			}
			else {
				break;
			}
		} while (NexthWnd != NULL);
	};


	PA_ReturnLong(params, lFound);

}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_MessageBox
//
// PURPOSE:		Exposes the MessageBox Win32 API function
//
// DATE:			DJD 2008-09-12
//
void gui_MessageBox(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR ownerHandleIndex;
	HWND ownerHandle;
	LONG_PTR messageText_len;
	char messageText[32000];
	LONG_PTR dialogTitle_len;
	char dialogTitle[32000];
	LONG_PTR dialogType;
	LONG_PTR returnValue;

	ownerHandleIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal handle array
	messageText_len = PA_GetTextParameter(params, 2, messageText);
	messageText[messageText_len] = '\0';
	dialogTitle_len = PA_GetTextParameter(params, 3, dialogTitle);
	dialogTitle[dialogTitle_len] = '\0';
	dialogType = PA_GetLongParameter(params, 4);

	if (isEx){
		ownerHandle = handleArray_retrieve(ownerHandleIndex); // WJF 9/16/15 #43731
	}
	else {
		ownerHandle = (HWND)ownerHandleIndex;
	}
	
	returnValue = MessageBoxEx(ownerHandle, (LPCSTR)messageText, (LPCSTR)dialogTitle, (UINT)dialogType, 0); // WJF 9/1/15 #43731 Removed typecasting on the handle

	PA_ReturnLong(params, returnValue);
}





//----------------------------------------------------------------------
//
// FUNCTION:	gui_SetMDIOpaque
//
// PURPOSE:		Make the main MDI window background opaque.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_SetMDIOpaque(PA_PluginParameters params)
{

	LONG_PTR returnValue;

	returnValue = SetLayeredWindowAttributes(windowHandles.fourDhWnd, GetSysColor(COLOR_APPWORKSPACE), 255, LWA_ALPHA);
	// REB 3/11/10 #23109 Set the window style back to the orignal value.
	if (windowStyle != 0){
		returnValue = SetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE, windowStyle);
	};

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_SetMDITransparent
//
// PURPOSE:		Make the main MDI window background transparent.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_SetMDITransparent(PA_PluginParameters params)
{

	LONG_PTR returnValue;
	// REB 3/11/10 #23109 Get the original window style before we mess around with it.
	windowStyle = GetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE);

	returnValue = SetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE, GetWindowLongPtr(windowHandles.fourDhWnd, GWL_EXSTYLE) | WS_EX_LAYERED);
	returnValue = SetLayeredWindowAttributes(windowHandles.fourDhWnd, GetSysColor(COLOR_APPWORKSPACE), 0, LWA_COLORKEY);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_HideTaskBar
//
// PURPOSE:		Hide the Windows taskbar.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_HideTaskBar(PA_PluginParameters params)
{
	HWND HWND_tray;
	LONG_PTR returnValue;

	HWND_tray = FindWindow("Shell_TrayWnd", NULL);
	returnValue = ShowWindow(HWND_tray, SW_HIDE);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}



//----------------------------------------------------------------------
//
// FUNCTION:	gui_ShowTaskBar
//
// PURPOSE:		Show the Windows taskbar.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_ShowTaskBar(PA_PluginParameters params)
{
	HWND HWND_tray;
	LONG_PTR returnValue;

	HWND_tray = FindWindow("Shell_TrayWnd", NULL);
	returnValue = ShowWindow(HWND_tray, SW_SHOW);

	// Reverse the return values so that a return value of 0 means there was an error
	// making the taskbar visible and non-zero if there were no problems.
	if (returnValue == 0){
		returnValue = 1;
	}
	else{
		returnValue = 0;
	};

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_HideTitleBar
//
// PURPOSE:		Hide the title bar of the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_HideTitleBar(PA_PluginParameters params)
{

	LONG_PTR returnValue;

	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) | WS_POPUP);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) &~WS_CAPTION);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) &~WS_SYSMENU);
	returnValue = SetWindowPos(windowHandles.fourDhWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}


//----------------------------------------------------------------------
//
// FUNCTION:	gui_ShowTitleBar
//
// PURPOSE:		Show the title bar of the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_ShowTitleBar(PA_PluginParameters params)
{

	LONG_PTR returnValue;

	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) &~WS_POPUP);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) | WS_CAPTION);
	SetWindowLong(windowHandles.fourDhWnd, GWL_STYLE, GetWindowLong(windowHandles.fourDhWnd, GWL_STYLE) | WS_SYSMENU);
	returnValue = SetWindowPos(windowHandles.fourDhWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_MaximizeMDI
//
// PURPOSE:		Maximize the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_MaximizeMDI(PA_PluginParameters params)
{

	LONG_PTR returnValue;
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_SHOWMAXIMIZED;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_MinimizeMDI
//
// PURPOSE:		Minimize the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_MinimizeMDI(PA_PluginParameters params)
{

	LONG_PTR returnValue;
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_SHOWMINIMIZED;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}

//----------------------------------------------------------------------
//
// FUNCTION:	gui_RestoreMDI
//
// PURPOSE:		Restore the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void gui_RestoreMDI(PA_PluginParameters params)
{

	LONG_PTR returnValue;
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(windowHandles.fourDhWnd, &wndpl);
	wndpl.showCmd = SW_RESTORE;
	returnValue = SetWindowPlacement(windowHandles.fourDhWnd, &wndpl);

	InvalidateRect(windowHandles.fourDhWnd, NULL, TRUE);
	UpdateWindow(GetDesktopWindow());

	PA_ReturnLong(params, returnValue);
}


//----------------------------------------------------------------------
//
// FUNCTION:	sys_DisableTaskManager
//
// PURPOSE:		Restore the MDI window.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void sys_DisableTaskManager(PA_PluginParameters params)
{

	LONG_PTR returnValue;
	HKEY hk;
	DWORD val = 1;

	if (!hookHandles.keyboardLLHook)
		hookHandles.keyboardLLHook = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKPROC)keyboardLLHook, (HINSTANCE)GetModuleHandle(0), 0);

	if (RegOpenKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk) != ERROR_SUCCESS)
		RegCreateKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk);

	returnValue = RegSetValueEx(hk, VAL_DisableTaskMgr, 0, REG_DWORD, (BYTE*)&val, sizeof(val));

	if (returnValue == ERROR_SUCCESS){
		returnValue = 1;
	}
	else{
		returnValue = 0;
	};

	PA_ReturnLong(params, returnValue);
}



//----------------------------------------------------------------------
//
// FUNCTION:	sys_EnableTaskManager
//
// PURPOSE:		Enable task manager.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
void sys_EnableTaskManager(PA_PluginParameters params)
{

	LONG_PTR returnValue;
	HKEY hk;

	if (hookHandles.keyboardLLHook)
	{
		UnhookWindowsHookEx(hookHandles.keyboardLLHook);
		hookHandles.keyboardLLHook = NULL;
	}

	if (RegOpenKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk) != ERROR_SUCCESS)
		RegCreateKey(HKEY_CURRENT_USER, KEY_DisableTaskMgr, &hk);

	returnValue = RegDeleteValue(hk, VAL_DisableTaskMgr);

	if (returnValue == ERROR_SUCCESS){
		returnValue = 1;
	}
	else{
		returnValue = 0;
	};

	PA_ReturnLong(params, returnValue);
}


// ------------------------------------------------
// 
//  FUNCTION: sys_SetRegKey( PA_PluginParameters params, LONG_PTR selector )
//
//  PURPOSE:  Set a registry key value.
//        
//	DATE:	  REB 11/17/10 #25402
//
void sys_SetRegKey(PA_PluginParameters params, LONG_PTR selector)
{
	LONG_PTR returnValue, regKey, retErr, dataSize, arraySize, value, expandDataSize, keyState;
	DWORD dwVal = 0;
	__int64 val64 = 0;
	LONG_PTR i, len;
	char regSub[MAXBUF];
	char regName[MAXBUF];
	char *newDataBuffer = NULL, *element = NULL, *pos = NULL;
	HKEY hRootKey;
	HKEY hOpenKey;
	DWORD dwDataType;
	PA_Variable	paReturnArray;

	returnValue = regKey = retErr = arraySize = expandDataSize = 0;
	hRootKey = hOpenKey = 0;
	newDataBuffer = NULL;
	memset(regSub, 0, MAXBUF);
	memset(regName, 0, MAXBUF);

	// Get the function parameters.
	regKey = PA_GetLongParameter(params, 1);
	PA_GetTextParameter(params, 2, regSub);
	PA_GetTextParameter(params, 3, regName);

	// Convert the 4d registry constant into a Windows registry key.
	hRootKey = getRootKey(regKey);

	// Open the registry key.
	retErr = RegOpenKeyEx(hRootKey, regSub, 0, KEY_ALL_ACCESS, &hOpenKey);

	returnValue = -99;

	// If the key does not exist create it now.
	if (retErr == ERROR_FILE_NOT_FOUND){
		returnValue = -98;
		//retErr = RegCreateKeyEx(hRootKey, regSub, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hOpenKey, &keyState);
		retErr = RegCreateKeyEx(hRootKey, regSub, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hOpenKey, &keyState);
	}

	if (retErr == ERROR_SUCCESS){

		returnValue = -97;

		// Get the value type from the registry.
		retErr = RegQueryValueEx(hOpenKey, regName, NULL, &dwDataType, NULL, &dataSize);

		// If the value was not found we'll need to determine the type based on the value passed in.
		if (retErr == ERROR_FILE_NOT_FOUND){

			switch (selector){

			case 90:
				dwDataType = REG_SZ;
				retErr = ERROR_SUCCESS;
				break;

			case 91:
				dwDataType = REG_DWORD;
				retErr = ERROR_SUCCESS;
				break;

			case 92:
				dwDataType = REG_MULTI_SZ;
				retErr = ERROR_SUCCESS;
				break;

			case 93:
				dwDataType = REG_BINARY;
				retErr = ERROR_SUCCESS;
				break;

			case 104:
				dwDataType = REG_QWORD;
				retErr = ERROR_SUCCESS;
				break;
			}
		}

		if (retErr == ERROR_SUCCESS){

			switch (dwDataType){
			case REG_BINARY:
				len = PA_GetBlobParameter(params, 4, NULL);
				newDataBuffer = malloc(len);
				len = PA_GetBlobParameter(params, 4, newDataBuffer);

				retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, newDataBuffer, len);

				free(newDataBuffer);

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}


				break;

			case REG_DWORD:
			case REG_DWORD_BIG_ENDIAN:
				value = PA_GetLongParameter(params, 4);
				dwVal = value; // WJF 8/31/15 #43731 Truncate to 32-bit DWORD
				retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, &dwVal, sizeof(dwVal));

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				break;


			case REG_MULTI_SZ:

				paReturnArray = PA_GetVariableParameter(params, 4);

				if (paReturnArray.uValue.fArray.fNbElements > 0){
					//Convert the 4D array into a null delimited string to be stored
					for (i = 1; i <= paReturnArray.uValue.fArray.fNbElements; i++)
					{
						arraySize += PA_GetTextInArray(paReturnArray, i, NULL) + 1;
					}

					newDataBuffer = malloc(arraySize + 1);
					memset(newDataBuffer, 0, arraySize + 1);
					pos = newDataBuffer;
					for (i = 1; i <= paReturnArray.uValue.fArray.fNbElements; i++)
					{
						len = PA_GetTextInArray(paReturnArray, i, NULL);
						element = malloc(len + 1);
						len = PA_GetTextInArray(paReturnArray, i, element);
						element[len] = '\0';

						memcpy(pos, element, len + 1);
						pos += len + 1;

						free(element);

					}

					retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, newDataBuffer, arraySize + 1);
					free(newDataBuffer);
				}

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				break;

			case REG_EXPAND_SZ:
			case REG_SZ:

				len = PA_GetTextParameter(params, 4, NULL) + 1;
				newDataBuffer = malloc(len * sizeof(char));
				memset(newDataBuffer, 0, (len * sizeof(char)));
				len = PA_GetTextParameter(params, 4, newDataBuffer);
				newDataBuffer[len] = '\0';

				retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, newDataBuffer, len);

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				free(newDataBuffer);

				break;

			case REG_QWORD: // WJF 8/31/15 #43731 Added Support for 64-bit QWORD
				value = PA_GetLongParameter(params, 4);
			    val64 = value; // Force to 64-bit
				retErr = RegSetValueEx(hOpenKey, regName, NULL, dwDataType, &val64, sizeof(val64));

				if (retErr == ERROR_SUCCESS){
					returnValue = 1;
				}
				else{
					returnValue = retErr * -1;
				}

				break;

			}
		}
	}

	RegCloseKey(hOpenKey);
	PA_ReturnLong(params, returnValue);
}






// ------------------------------------------------
// 
//  FUNCTION: sys_IsAppRunningAsService( PA_PluginParameters params, LONG_PTR selector )
//
//  PURPOSE:  Determine if the application is running as a service.
//        
//	DATE:	  REB 1/12/11 #25587, contributed by Justin Carr
//
void sys_IsAppRunningAsService(PA_PluginParameters params)
{
	short serviceInd = 0;
	SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
	PSID pServiceSid = NULL;
	PSID pLocalSystemSid = NULL;
	BOOL bHasServiceSid;
	BOOL bHasLocalSystemSid;

	if (AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &pServiceSid)){
		if (CheckTokenMembership(NULL, pServiceSid, &bHasServiceSid)) {
			if (bHasServiceSid) {
				serviceInd = 1;
			}
			else if (AllocateAndInitializeSid(&siaNt, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pLocalSystemSid)) {
				if (CheckTokenMembership(NULL, pLocalSystemSid, &bHasLocalSystemSid)) {
					if (bHasLocalSystemSid) {
						serviceInd = 1;
					}
				}
			}
		}
	}

	if (pLocalSystemSid)
		FreeSid(pLocalSystemSid);

	if (pServiceSid)
		FreeSid(pServiceSid);

	PA_ReturnShort(params, serviceInd);

}



// ------------------------------------------------
// 
//  FUNCTION: sys_CompareBLOBs( PA_PluginParameters params )
//
//  PURPOSE:  Compare two BLOBs and return 1 if they are equal and 0 if they are not.
//        
//	DATE:	  // REB 11/9/12 TESTING
//
void sys_CompareBLOBs(PA_PluginParameters params)
{
	LONG_PTR returnValue = 0;
	LONG_PTR len1, len2;
	char *BLOB1 = NULL;
	char *BLOB2 = NULL;

	len1 = PA_GetBlobParameter(params, 1, NULL);
	BLOB1 = malloc(len1);
	len1 = PA_GetBlobParameter(params, 1, BLOB1);

	len2 = PA_GetBlobParameter(params, 2, NULL);
	BLOB2 = malloc(len2);
	len2 = PA_GetBlobParameter(params, 2, BLOB2);

	if (len1 == len2){
		returnValue = memcmp(BLOB1, BLOB2, len1);
	}
	else{
		returnValue = -1;
	}

	free(BLOB1);
	free(BLOB2);

	PA_ReturnLong(params, returnValue);

}


//----------------------------------------------------------------------
//
// FUNCTION:	keyboardLLHook
//
// PURPOSE:		Hook to handle low level keyboard events.
//
// REB 1/8/10 #22389 Code contributed by miyako
//
LRESULT CALLBACK keyboardLLHook(INT_PTR code, WPARAM wParam, LPARAM lParam)
{

	KBDLLHOOKSTRUCT *pkh = (KBDLLHOOKSTRUCT *)lParam;
	BOOL bCtrlKeyDown = FALSE;
	BOOL bAltKeyDown = FALSE;
	BOOL bShiftKeyDown = FALSE;

	if (code == HC_ACTION) {
		bCtrlKeyDown = GetAsyncKeyState(VK_CONTROL) >> ((sizeof(SHORT)* 8) - 1);
		bShiftKeyDown = GetAsyncKeyState(VK_SHIFT) >> ((sizeof(SHORT)* 8) - 1);
		bAltKeyDown = pkh->flags & LLKHF_ALTDOWN;

		if ((pkh->vkCode == VK_ESCAPE && bCtrlKeyDown) ||					// Ctrl+Esc
			(pkh->vkCode == VK_TAB && bAltKeyDown) ||						// Alt+Tab
			(pkh->vkCode == VK_ESCAPE && bAltKeyDown) ||					// Alt+Esc
			(pkh->vkCode == VK_ESCAPE && bCtrlKeyDown && bShiftKeyDown) || // Ctrl+Shift+Esc			
			(pkh->vkCode == VK_F4 && bAltKeyDown) ||						// Alt+F4			
			(pkh->vkCode == VK_LWIN || pkh->vkCode == VK_RWIN))				// Start Menu
		{
			return 1;
		}
	}
	return CallNextHookEx(hookHandles.keyboardLLHook, code, wParam, lParam);
}


//----------------------------------------------------------------------
//
// FUNCTION:	sys_GetFileVersionInfo
//
// PURPOSE:		Return file version information 
//
// AMS 2/14/14 #36899
//
void sys_GetFileVersionInfo(PA_PluginParameters params)
{
	char *verData = NULL;
	char *file = NULL;
	DWORD verHandle = NULL;
	DWORD verSize = NULL;

	LONG_PTR ret = 0;
	LONG_PTR major = 0;
	LONG_PTR minor = 0;
	LONG_PTR rev = 0;
	LONG_PTR build = 0;

	UINT size = 0;
	LPBYTE *lpBuffer = NULL;

	file = getTextParameter(params, 1);

	verSize = GetFileVersionInfoSize(file, &verHandle);

	if (0 != verSize)
	{
		verData = malloc(verSize);
		if (GetFileVersionInfo(file, verHandle, verSize, verData))
		{
			ret = 1;
			if (VerQueryValue(verData, "\\", (VOID FAR* FAR*)&lpBuffer, &size))
			{
				if (size)
				{
					VS_FIXEDFILEINFO *verInfo = (VS_FIXEDFILEINFO *)lpBuffer;
					if (verInfo->dwSignature == 0xfeef04bd)
					{
						major = HIWORD(verInfo->dwFileVersionMS);
						minor = LOWORD(verInfo->dwFileVersionMS);
						build = HIWORD(verInfo->dwFileVersionLS);
						rev = LOWORD(verInfo->dwFileVersionLS);
					}

				}

			}

		}

		else
		{
			ret = GetLastError();
		}

		free(verData);

	}

	free(file);

	PA_SetLongParameter(params, 2, (LONG)major);
	PA_SetLongParameter(params, 3, (LONG)minor);
	PA_SetLongParameter(params, 4, (LONG)build);
	PA_SetLongParameter(params, 5, (LONG)rev);

	PA_ReturnLong(params, (LONG)ret);

}

//----------------------------------------------------------------------
//
// FUNCTION:	sys_SendRawPrinterData
//
// PURPOSE:		Sends raw printer data directly to a printer. sys_PrintDirect2Driver
//
//
// AMS 12/5/14 #37816
//

void sys_SendRawPrinterData(PA_PluginParameters params){
	PRINTDLG pd;                      // Structure to hold information about printer
	DOCINFO di;                       // Structure to hold "document" information
	char printerName[MAXBUF] = "";    // String to hold the printerName param ($1)
	char data[MAXLABELBUF] = "";      // String to hold the data param ($2) REB 6/5/08 #17022 Changed MAXBUF to MAXLABELBUF which is twice as big.
	char *origDefault;                // String to hold the original default printer
	INT_PTR printerName_len;              // Int to hold maximum length of printer name
	INT_PTR ret;                          // Int to hold return value of functions                 
	INT_PTR iErrCode = 1;                 // Int to hold the error code.
	ULONG_PTR ulBytesNeeded;      // Holds size information

	BOOL     bStatus = FALSE;
	HANDLE     hPrinter = NULL;
	DOC_INFO_1 DocInfo;
	DWORD      dwJob = 0L;
	DWORD      dwBytesWritten = 0L;


	// Set needed bytes to default value
	ulBytesNeeded = MAXLABELBUF; // REB 6/5/08 #17022 Changed MAXBUF to MAXLABELBUF

	// Set this to 255.
	printerName_len = 255;

	// Get the function parameters.
	PA_GetTextParameter(params, 1, printerName);
	PA_GetTextParameter(params, 2, data);

	// Allocate memory for Storing string for Original Default Printer & pBuf
	origDefault = (char *)malloc(ulBytesNeeded);
	memset(origDefault, 0, ulBytesNeeded);

	// Get name of current Default Printer
	GetDefaultPrinter(origDefault, &ulBytesNeeded);

	// Set the new Default Printer to our label printer, with the name obtained from the registry
	ret = SetDefaultPrinter((char *)printerName);

	// We set the default printer just fine, now let's do the printing.
	if (ret != 0)
	{
		// Open a handle to the printer. 
		bStatus = OpenPrinter(printerName, &hPrinter, NULL);
		if (bStatus)
		{
			// Fill in the structure with info about this "document." 
			DocInfo.pDocName = (LPTSTR)("My Document");
			DocInfo.pOutputFile = NULL;
			DocInfo.pDatatype = (LPTSTR)("RAW");

			// Inform the spooler the document is beginning. 
			dwJob = StartDocPrinter(hPrinter, 1, (LPBYTE)&DocInfo);
			if (dwJob > 0) {
				// Start a page. 
				bStatus = StartPagePrinter(hPrinter);
				if (bStatus) {
					// Send the data to the printer. 
					bStatus = WritePrinter(hPrinter, data, MAXLABELBUF, &dwBytesWritten);
					EndPagePrinter(hPrinter);
				}
				// Inform the spooler that the document is ending. 
				EndDocPrinter(hPrinter);
			}
			// Close the printer handle. 
			ClosePrinter(hPrinter);
		}
		// Check to see if correct number of bytes were written. 
		if (!bStatus || (dwBytesWritten != MAXLABELBUF))
		{
			bStatus = FALSE;
			iErrCode = GetLastError();
		}
		else
		{
			bStatus = TRUE;
			iErrCode = 0;
		}

	}

	ret = SetDefaultPrinter(origDefault); // WJF 6/9/15 #40818

	free(origDefault); // WJF 6/5/15 #42792

	PA_ReturnLong(params, iErrCode);
}

/*
void sys_SendRawPrinterData(PA_PluginParameters params)
{
// 4D Parameters
char szPrinterName[255] = "";  // Text printer name
char szData[MAXLABELBUF] = "";  // Text printer data
DWORD dwCount = 0;  // Long printer data length
char szDocName[255] = "";  // Text document name

BOOL			bStatus = FALSE;
HANDLE			hPrinter = NULL;
DOC_INFO_1		DocInfo;
DWORD			dwJob = 0L;
DWORD			dwBytesWritten = 0L;
LONG_PTR		lpReturn = 0;
char			*origDefault;  // String to hold the original default printer
ULONG_PTR		ulBytesNeeded;      // Holds size information

// Set needed bytes to default value
ulBytesNeeded = MAXLABELBUF;

PA_GetTextParameter(params, 1, szPrinterName);
PA_GetTextParameter(params, 2, szData);
PA_GetLongParameter(params, 3, dwCount);
PA_GetTextParameter(params, 4, szDocName);

// Allocate memory for Storing string for Original Default Printer & pBuf
origDefault = (char *)malloc(ulBytesNeeded);
memset(origDefault, 0, ulBytesNeeded);

GetDefaultPrinter(origDefault, &ulBytesNeeded);

// Set the new Default Printer to our label printer, with the name obtained from the registry
lpReturn = SetDefaultPrinter((char *)szPrinterName);

if (lpReturn != 0)
{
// Open a handle to the printer.
bStatus = OpenPrinter(szPrinterName, &hPrinter, NULL);
if (bStatus) {
// Fill in the structure with info about this "document."
DocInfo.pDocName = (LPTSTR)szDocName;
DocInfo.pOutputFile = NULL;
DocInfo.pDatatype = (LPTSTR)("RAW");

// Inform the spooler the document is beginning.
dwJob = StartDocPrinter(hPrinter, 1, (LPBYTE)&DocInfo);
if (dwJob > 0) {
// Start a page.
bStatus = StartPagePrinter(hPrinter);
if (bStatus) {
// Send the data to the printer.
bStatus = WritePrinter(hPrinter, szData, dwCount, &dwBytesWritten);
EndPagePrinter(hPrinter);
}
// Inform the spooler that the document is ending.
EndDocPrinter(hPrinter);
}
// Close the printer handle.
ClosePrinter(hPrinter);
}
// Check to see if correct number of bytes were written.
if (!bStatus || (dwBytesWritten != dwCount)) {
bStatus = FALSE;
lpReturn = 1;
}
else {
bStatus = TRUE;
lpReturn = 0;
}
lpReturn = SetDefaultPrinter(origDefault);
}
PA_ReturnLong(params, lpReturn);
}
*/

//  FUNCTION: sys_setCursor(PA_PluginParameters params)
//
//  PURPOSE:	Sets the cursor based on the passed value
//
//  COMMENTS:	
//
//	DATE:		WJF 4/10/15 #23512
/*
void sys_SetCursor(PA_PluginParameters params){

long lCursor = 0;

lCursor = PA_GetLongParameter(params, 1);

switch (lCursor)
{
case 1:
cursorHandle = LoadCursor(NULL, IDC_IBEAM);
cursorHandleSet = TRUE;
break;
case 2:
cursorHandle = LoadCursor(NULL, IDC_CROSS);
cursorHandleSet = TRUE;
break;
case 3:
cursorHandle = LoadCursor(NULL, IDC_SIZEALL);
cursorHandleSet = TRUE;
break;
case 4:
cursorHandle = LoadCursor(NULL, IDC_WAIT);
cursorHandleSet = TRUE;
break;
default:
cursorHandle = LoadCursor(NULL, IDC_ARROW);
cursorHandleSet = FALSE;
break;
}

SetClassLong(windowHandles.MDIhWnd, GCL_HCURSOR, NULL);
SetCursor(cursorHandle);


PA_ReturnLong(params, 0);
}*/

//  FUNCTION: sys_DeleteRegKey(PA_PluginParameters params)
//
//  PURPOSE:	Deletes a registry key
//
//  COMMENTS:	
//
//	DATE:		WJF 4/14/15 #27474
void sys_DeleteRegKey(PA_PluginParameters params)
{
	HKEY hKey = 0;
	short baseKey = 0;
	char subKey[255];
	long errorCode = 0;

	baseKey = PA_GetLongParameter(params, 1);
	PA_GetTextParameter(params, 2, subKey);

	hKey = getRootKey(baseKey);

	if (hKey != 0)
	{
		errorCode = RegOpenKeyEx(hKey, NULL, 0, KEY_ALL_ACCESS, &hKey); // Open key

		if (errorCode == ERROR_SUCCESS){
			errorCode = RegDeleteKey(hKey, TEXT(subKey));
		}
		RegCloseKey(hKey); // Keys aren't deleted until they are closed
	}

	PA_ReturnLong(params, errorCode);
}

//  FUNCTION: sys_DeleteRegKey64(PA_PluginParameters params)
//
//  PURPOSE:	Deletes a registry key, used for 64-bit Windows
//
//  COMMENTS:	Passing non-1 values is the same as calling sys_DeleteRegKey on 64-bit
//
//	DATE:		WJF 4/14/15 #27474
/* WJF 6/12/15 #42964 Removed for now since RegDeleteKeyEx merely existing in the code causes Win32API to crash on 32bit XP
void sys_DeleteRegKey64(PA_PluginParameters params)
{
	HKEY hKey = 0;
	short baseKey = 0;
	char subKey[255];
	long errorCode = 0;
	REGSAM regView;
	long view = 0;

	baseKey = PA_GetLongParameter(params, 1);
	PA_GetTextParameter(params, 2, subKey);
	view = PA_GetLongParameter(params, 3);

	switch (view)
	{
	case 1:
		regView = KEY_WOW64_64KEY;
		break;
	default:
		regView = KEY_WOW64_32KEY;
	}

	hKey = getRootKey(baseKey);

	if (errorCode != -1)
	{
		errorCode = RegOpenKeyEx(hKey, NULL, 0, KEY_ALL_ACCESS, &hKey); // Open Key
		if (errorCode == ERROR_SUCCESS)
		{
			RegDeleteKeyEx(hKey, TEXT(subKey), regView, 0);
		}
		RegCloseKey(hKey); // Keys aren't deleted until they are closed
	}

	PA_ReturnLong(params, errorCode);
}*/

//  FUNCTION: sys_DeleteRegValue(PA_PluginParameters params)
//
//  PURPOSE:	Deletes a registry value
//
//  COMMENTS:	
//
//	DATE:		WJF 4/14/15 #27474
void sys_DeleteRegValue(PA_PluginParameters params)
{
	HKEY hKey = 0;
	short baseKey = 0;
	char subKey[255];
	long errorCode = 0;
	char keyValue[255];

	baseKey = PA_GetLongParameter(params, 1);
	PA_GetTextParameter(params, 2, subKey);
	PA_GetTextParameter(params, 3, keyValue);

	hKey = getRootKey(baseKey);

	if (hKey != 0)
	{
		errorCode = RegOpenKeyEx(hKey, TEXT(subKey), 0, KEY_ALL_ACCESS, &hKey);

		if (errorCode == ERROR_SUCCESS){
			errorCode = RegDeleteValue(hKey, TEXT(keyValue));
		}
		RegCloseKey(hKey); // Values aren't deleted until the key is closed
	}

	PA_ReturnLong(params, errorCode);
}

//  FUNCTION:	gui_TakeScreenshot (PA_PluginParameters params)
//
//  PURPOSE:	Takes a screenshot of the desktop
//
//  COMMENTS:	
//
//	DATE:		WJF 7/7/15 #43138

void gui_TakeScreenshot(PA_PluginParameters params, BOOL isEx){

	LONG_PTR				hWndIndex;
	RECT					rcClient;
	int						lError = 0;
	HDC						hdcScreen;
	HDC						hdcWindow;
	HDC						hdcMemDC;
	HBITMAP					hbmScreen;
	BITMAP					bmpScreen;
	DWORD					dwBmpSize;
	HANDLE					hDIB;
	char					*lpbitmap;
	HANDLE					hFile;
	DWORD					dwSizeofDIB;
	DWORD					dwBytesWritten;
	char					*filePath;
	DWORD					dwFilePathLength;
	BITMAPFILEHEADER		bmfHeader;
	BITMAPINFOHEADER		bi;
	HWND					hWnd;

	hWndIndex = PA_GetLongParameter(params, 1); // WJF 9/1/15 #43731 We are now getting an index to an internal array;

	dwFilePathLength = PA_GetTextParameter(params, 2, NULL);
	filePath = (char *)malloc(dwFilePathLength);
	dwFilePathLength = PA_GetTextParameter(params, 2, filePath);

	if (isEx){ // WJF 9/16/15 #43731
		hWnd = handleArray_retrieve((DWORD)hWndIndex); 
	}
	else {
		hWnd = (HWND)hWndIndex;
	}

	if (IsWindow(hWnd)) {
		// Get a screen DC and a DC for the window for which the handle was provided
		hdcScreen = GetDC(NULL);
		hdcWindow = GetDC(hWnd);

		// Create a compatible DC which is used in a BitBlt from the window DC
		hdcMemDC = CreateCompatibleDC(hdcWindow);

		if (hdcMemDC) {

			// Get the client area for size calculation
			GetClientRect(hWnd, &rcClient);
			// Adjust for caption bar and borders
			rcClient.top -= GetSystemMetrics(SM_CYCAPTION);
			rcClient.bottom += 5;
			rcClient.left -= 5;
			rcClient.right += 5;

			// Create a compatible bitmap from the Window DC
			hbmScreen = CreateCompatibleBitmap(hdcWindow, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);

			if (hbmScreen){

				// Select the compatible bitmap into the compatible memory DC.
				SelectObject(hdcMemDC, hbmScreen);

				// Bit block transfer into our compatible memory DC.
				if (BitBlt(hdcMemDC, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, hdcWindow, rcClient.left, rcClient.top, SRCCOPY)) {

					// Get the BITMAP from the HBITMAP
					GetObject(hbmScreen, sizeof(BITMAP), &bmpScreen);

					bi.biSize = sizeof(BITMAPINFOHEADER);
					bi.biWidth = bmpScreen.bmWidth;
					bi.biHeight = bmpScreen.bmHeight;
					bi.biPlanes = 1;
					bi.biBitCount = 32;
					bi.biCompression = BI_RGB;
					bi.biSizeImage = 0;
					bi.biXPelsPerMeter = 0;
					bi.biYPelsPerMeter = 0;
					bi.biClrUsed = 0;
					bi.biClrImportant = 0;

					dwBmpSize = ((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight;

					// Starting with 32-bit Windows, GlobalAlloc and LocalAlloc are implemented as wrapper functions that 
					// call HeapAlloc using a handle to the process's default heap. Therefore, GlobalAlloc and LocalAlloc 
					// have greater overhead than HeapAlloc.
					hDIB = GlobalAlloc(GHND, dwBmpSize);
					lpbitmap = (char *)GlobalLock(hDIB);

					// Gets the "bits" from the bitmap and copies them into a buffer 
					// which is pointed to by lpbitmap.
					GetDIBits(hdcWindow, hbmScreen, 0, (UINT)bmpScreen.bmHeight, lpbitmap, (BITMAPINFO *)&bi, DIB_RGB_COLORS);

					// A file is created, this is where we will save the screen capture.
					hFile = CreateFile(filePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

					// Add the size of the headers to the size of the bitmap to get the total file size
					dwSizeofDIB = dwBmpSize + sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);

					// Offset to where the actual bitmap bits start.
					bmfHeader.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER)+(DWORD)sizeof(BITMAPINFOHEADER);

					// Size of the file
					bmfHeader.bfSize = dwSizeofDIB;

					// bfType must always be BM for Bitmaps
					bmfHeader.bfType = 0x4D42; //BM   

					dwBytesWritten = 0;
					WriteFile(hFile, (LPSTR)&bmfHeader, sizeof(BITMAPFILEHEADER), &dwBytesWritten, NULL);
					WriteFile(hFile, (LPSTR)&bi, sizeof(BITMAPINFOHEADER), &dwBytesWritten, NULL);
					WriteFile(hFile, (LPSTR)lpbitmap, dwBmpSize, &dwBytesWritten, NULL);

					// Unlock and Free the DIB from the heap
					GlobalUnlock(hDIB);
					GlobalFree(hDIB);

					// Close the handle for the file that was created
					CloseHandle(hFile);

				}
				else {
					lError = 3;
				}

				DeleteObject(hbmScreen);

			}
			else {
				lError = 2;
			}

			DeleteObject(hdcMemDC);
		}
		else {
			lError = 1;
		}

		ReleaseDC(NULL, hdcScreen);
		ReleaseDC(hWnd, hdcWindow);
	}
	else {
		lError = 4;
	}

	free(filePath);

	PA_ReturnLong(params, lError);

}


//  FUNCTION:	handleArray_add (LONG_PTR hWND)
//
//  PURPOSE:	Adds a handle to the internal handle array
//
//  COMMENTS:	
//
//	DATE:		WJF 9/1/15 #43731
DWORD handleArray_add(LONG_PTR hWND){
	int i = 0;
	BOOL hasEmptySlot = FALSE;
	DWORD dwResult = 0;

	// Wait for the mutex
	dwResult = WaitForSingleObject(hArrayMutex, 2000);

	if (dwResult == WAIT_OBJECT_0){
		__try{
			// Find first empty slot
			while (i < HANDLEARRAY_CAPACITY){
				if (handleArray[i] == 0){
					hasEmptySlot = TRUE;
					break;
				}
				else {
					i++;
				}
			}

			if (hasEmptySlot){
				handleArray[i] = hWND;
			}
		}
		__finally {
			ReleaseMutex(hArrayMutex);
		}

		if (hasEmptySlot){
			return i;
		}
		else {
			return -1;
		}
	}
	else {
		return -1;
	}
}

//  FUNCTION:	handleArray_init ()
//
//  PURPOSE:	Initializes the internal handle array and its mutex object
//
//  COMMENTS:	
//
//	DATE:		WJF 9/1/15 #43731
DWORD handleArray_init(){

	for (int i = 0; i < HANDLEARRAY_CAPACITY; i++)
		handleArray[i] = 0;
		
	hArrayMutex = CreateMutex(NULL, FALSE, NULL);

	if (hArrayMutex == NULL){
		return GetLastError();
	}
	else {
		return ERROR_SUCCESS;
	}


}

//  FUNCTION:	handleArray_remove (PA_PluginParameters params)
//
//  PURPOSE:	Removes a handle from the internal handle array
//
//  COMMENTS:	gui_FreeHandle
//
//	DATE:		WJF 9/1/15 #43731
DWORD handleArray_remove(PA_PluginParameters params){
	LONG index = 0;
	DWORD errorCode = -1;

	index = PA_GetLongParameter(params, 1);

	if ((index >= 0) && (index < HANDLEARRAY_CAPACITY)){

		errorCode = WaitForSingleObject(hArrayMutex, 2000);
		if (errorCode == WAIT_OBJECT_0){
			__try{
				handleArray[index] = 0;
			}
			__finally {
				ReleaseMutex(hArrayMutex);
			}
		}

	}

	PA_ReturnLong(params, errorCode);

	return errorCode;
}

//  FUNCTION:	handleArray_free (PA_PluginParameters params)
//
//  PURPOSE:	"Frees" all handle in the internal handle array, setting their values to 0.
//
//  COMMENTS:	
//
//	DATE:		WJF 9/1/15 #43731
DWORD handleArray_free(PA_PluginParameters params){
	DWORD errorCode = 0;

	errorCode = WaitForSingleObject(hArrayMutex, 2000);

	if (errorCode == WAIT_OBJECT_0){
		__try {
			for (int i = 0; i < HANDLEARRAY_CAPACITY; i++)
				handleArray[i] = 0;
		}
		__finally {
			ReleaseMutex(hArrayMutex);
		}
	}

	PA_ReturnLong(params, errorCode);

	return errorCode;
}

//  FUNCTION:	handleArray_retrieve (DWORD handleIndex)
//
//  PURPOSE:	Common method to return a handle from the handleArray
//
//  COMMENTS:	
//
//	DATE:		WJF 9/16/15 #43731
HWND handleArray_retrieve(DWORD handleIndex){
	LONG_PTR handle = 0;
	
	if ((handleIndex >= 0) && (handleIndex < HANDLEARRAY_CAPACITY)){
		handle = handleArray[handleIndex];
	}

	return (HWND)handle;
}

//  FUNCTION:	gui_GetWindowEx (PA_PluginParameters params, HWND hWnd)
//
//  PURPOSE:	Finds a handle, adds it to the internal handle array, and returns the index
//
//  COMMENTS:	
//
//	DATE:		WJF 9/15/15 #43731
void gui_GetWindowEx(PA_PluginParameters params, HWND hWnd)
{
	LONG_PTR			windowTitle_len;
	char				*windowTitle;
	long				returnValue = -1;
	LONG_PTR			windowHandle = 0;

	windowTitle_len = PA_GetTextParameter(params, 1, NULL) + 1;
	windowTitle = malloc(windowTitle_len * sizeof(char));
	memset(windowTitle, 0, (windowTitle_len * sizeof(char)));
	windowTitle_len = PA_GetTextParameter(params, 1, windowTitle);
	windowTitle[windowTitle_len] = '\0';

	if (strcmp(windowTitle, "*") == 0) { // return the frontmost window
		windowHandle = (LONG_PTR)hWnd;

	}
	else {
		if ((strlen(windowTitle) == 0) && (windowHandles.MDIs_4DhWnd != NULL)) {
			windowHandle = (LONG_PTR)windowHandles.fourDhWnd;
		}
		else if ((strcmp(_strlwr(windowTitle), "mdi") == 0) && (windowHandles.MDIhWnd != NULL)) {
			windowHandle = (LONG_PTR)windowHandles.MDIhWnd;
		}
		else {
			windowHandle = (LONG_PTR)getWindowHandle(windowTitle, hWnd);
		}
		if (!windowHandle) {
			returnValue = -3;
		}
	}

	if (windowHandle){
		returnValue = handleArray_add(windowHandle);
	}

	free(windowTitle);

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	gui_GetWindowFrom4DWinEx (PA_PluginParameters params)
//
//  PURPOSE:	Finds a handle, adds it to the internal handle array, and returns the index
//
//  COMMENTS:	
//
//	DATE:		WJF 9/15/15 #43731
void gui_GetWindowFrom4DWinEx(PA_PluginParameters params)
{
	LONG_PTR h4DWnd = 0;
	LONG_PTR windowHandle = 0;
	LONG_PTR serverValue = 0;
	long returnValue = 0;

	h4DWnd = PA_GetLongParameter(params, 1);

	windowHandle = PA_GetHWND(h4DWnd);

	returnValue = handleArray_add(windowHandle); 

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	gui_SetForegroundWindow (PA_PluginParameters params)
//
//  PURPOSE:	Finds a handle, adds it to the internal handle array, and returns the index
//
//  COMMENTS:	Needed for Automated Testing
//
//	DATE:		WJF 9/15/15 #43731
void gui_SetForegroundWindow(PA_PluginParameters params, BOOL isEx)
{
	LONG_PTR			index = 0;
	BOOL				bResult = FALSE;
	long				returnValue = 0;
	HWND				hWnd = NULL;

	index = PA_GetLongParameter(params, 1);

	if (isEx){ 
		hWnd = handleArray_retrieve((DWORD)index);
	}
	else {
		hWnd = (HWND)index;
	}
	
	if (IsWindow(hWnd)){
		bResult = SetForegroundWindow(hWnd);
	}

	if (bResult){
		returnValue = 1;
	}

	PA_ReturnLong(params, returnValue);
}

//  FUNCTION:	gui_SetFocusEx (PA_PluginParameters params)
//
//  PURPOSE:	Sets the focus to the specified window
//
//  COMMENTS:   
//
//	DATE:		WJF 10/19/15 Win-3
void gui_SetFocusEx(PA_PluginParameters params){
	HWND hWnd = NULL;
	DWORD index = 0;
	DWORD targetThread = 0;
	DWORD thisThread = 0;
	LONG error = 1;

	index = PA_GetLongParameter(params, 1);

	hWnd = handleArray_retrieve(index);

	if (IsWindow(hWnd)){
		thisThread = GetCurrentThreadId();
		targetThread = GetWindowThreadProcessId(hWnd, 0);
		
		if (thisThread == targetThread){
			SetFocus(hWnd);
			error = 0;
		}
		else if (AttachThreadInput(thisThread, targetThread, TRUE)){
			SetFocus(hWnd);
			AttachThreadInput(thisThread, targetThread, FALSE);
			error = 0;
		}
	}

	PA_ReturnLong(params, error);
}

//  FUNCTION: fileEncryption(PA_PluginParameters params, BOOL bDecrypt)
//
//  PURPOSE:	Encrypts/Decrypts a file
//
//  COMMENTS:	
//
//	DATE:		WJF 10/28/15 Win-4
void fileEncryption(PA_PluginParameters params, BOOL bDecrypt)
{
	HCRYPTPROV	hProv = 0;
	HCRYPTHASH	hHash = 0;
	HCRYPTKEY	hKey = 0;
	HANDLE		hSourceFile = NULL;
	HANDLE		hDestFile = NULL;
	CHAR		*fileSource = NULL;
	CHAR		*fileDest = NULL;
	DWORD		dwSize = 0;
	BYTE		pbPass[33] = "0";
	DWORD		dwPassLength = 0;
	DWORD		BUFFER_SIZE = 0;
	BYTE		IV[17] = "0";
	DWORD		dwIVLength = 0;
	BYTE		tempIV[17] = "0";
	DWORD		error = 0;
	LPCSTR		myContainer = "MyContainer";
	PBYTE		pbBuffer = NULL;
	DWORD		dwBlockLen = 0;
	DWORD		dwBufferLen = 0;
	DWORD		dwCount = 0;
	BOOL		fEOF = FALSE;
	LONG		returnCode = 1;

	__try {

		dwSize = PA_GetTextParameter(params, 1, NULL);

		if (!(fileSource = (CHAR *)malloc(dwSize))){
			__leave;
		}

		dwSize = PA_GetTextParameter(params, 1, fileSource);

		dwSize = PA_GetTextParameter(params, 2, NULL);

		if (!(fileDest = (CHAR *)malloc(dwSize))){
			__leave;
		}

		dwSize = PA_GetTextParameter(params, 2, fileDest);

		dwPassLength = PA_GetTextParameter(params, 3, pbPass);

		if (dwPassLength > 32) {
			__leave;
		}

		dwIVLength = PA_GetTextParameter(params, 4, tempIV);

		// Clean up the IV input
		for (int i = 0; i < 16; i++){
			if (i <= dwIVLength){
				if (tempIV[i] == '\0'){
					IV[i] = '0';
				}
				else {
					IV[i] = tempIV[i];
				}
			}
			else {
				IV[i] = '0';
			}
		}

		// Open the source file
		hSourceFile = CreateFile(fileSource, FILE_READ_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hSourceFile == INVALID_HANDLE_VALUE){
			__leave;
		}

		// Open the destination file
		hDestFile = CreateFile(fileDest, FILE_WRITE_DATA, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hDestFile == INVALID_HANDLE_VALUE){
			__leave;
		}

		// Get security provider
		if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))){
			error = GetLastError();
			if (error == 2148073487){
				if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))){
					__leave;
				}
			}
			else {
				__leave;
			}
		}

		// Create hash object
		if (!(CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))){
			__leave;
		}

		// Hash the password
		if (!(CryptHashData(hHash, pbPass, dwPassLength, 0))){
			__leave;
		}

		// Derive the key from the hashed password
		if (!(CryptDeriveKey(hProv, CALG_AES_256, hHash, CRYPT_EXPORTABLE, &hKey))){
			__leave;
		}

		// Destroy the hash object
		if (!(CryptDestroyHash(hHash))){
			__leave;
		}
		else {
			hHash = 0;
		}

		// Set IV
		if (!(CryptSetKeyParam(hKey, KP_IV, &IV, 0))){
			__leave;
		}

		dwBlockLen = 1000 - 1000 % AES_BLOCK_SIZE;

		if (bDecrypt)
		{
			dwBufferLen = dwBlockLen;
		}
		else {
			dwBufferLen = dwBlockLen + AES_BLOCK_SIZE;
		}
		
		if (!(pbBuffer = (BYTE *)malloc(dwBufferLen))){
			__leave;
		}

		do{
			if (!ReadFile(hSourceFile, pbBuffer, dwBlockLen, &dwCount, NULL)){
				__leave;
			}

			if (dwCount < dwBlockLen){
				fEOF = TRUE;
			}

			if (bDecrypt){
				if (!CryptDecrypt(hKey, 0, fEOF, 0, pbBuffer, &dwCount)){
					__leave;
				}
			}
			else {
				if (!CryptEncrypt(hKey, NULL, fEOF, 0, pbBuffer, &dwCount, dwBufferLen)){
					__leave;
				}
			}

			if (!WriteFile(hDestFile, pbBuffer, dwCount, &dwCount, NULL)){
				__leave;
			}

		} while (!fEOF);

		returnCode = ERROR_SUCCESS;

	}
	__finally{

		if (hSourceFile){
			CloseHandle(hSourceFile);
		}

		if (hDestFile){
			CloseHandle(hDestFile);
		}

		if (pbBuffer){
			free(pbBuffer);
			pbBuffer = NULL;
		}

		if (fileSource){
			free(fileSource);
			fileSource = NULL;
		}

		if (fileDest){
			free(fileDest);
			fileDest = NULL;
		}

		if (hKey) {
			CryptDestroyKey(hKey);
			hKey = 0;
		}

		if (hHash) {
			CryptDestroyHash(hHash);
			hHash = 0;
		}

		if (hProv){
			CryptReleaseContext(hProv, 0);
			hProv = 0;
		}

		PA_ReturnLong(params, returnCode);
	}
}

//  FUNCTION: sys_HashText(PA_PluginParameters params)
//
//  PURPOSE:	Hashes text and returns it
//
//  COMMENTS:	
//
//	DATE:		WJF 10/28/15 Win-4
void sys_HashText(PA_PluginParameters params){
	LPSTR		lpInput = NULL;
	DWORD		dwSize = 0;
	LONG		lAlgorithm = 0;
	ALG_ID		algorithm = 0;
	CHAR		provider[64] = "";
	DWORD		provType = 0;
	HCRYPTPROV	hProv = 0;
	HCRYPTHASH	hHash = 0;
	DWORD		error = 0;
	LPCSTR		myContainer = "MyContainer";
	LONG		returnCode = 1;
	BYTE		*pbData = NULL;
	DWORD		dwDataSize = 0;
	DWORD		dwCount = 0;
	LPSTR		lpOutput = NULL;
	CHAR        *pOutput = NULL;
	DWORD		dwOutSize = 0;

	__try{
		dwSize = PA_GetTextParameter(params, 1, NULL);

		if (!(lpInput = (CHAR *)malloc(dwSize+1))){
			__leave;
		}

		dwSize = PA_GetTextParameter(params, 1, lpInput);

		lAlgorithm = PA_GetLongParameter(params, 2);

		switch (lAlgorithm){
		case 0:
			algorithm = CALG_MD5;
			strcpy_s(provider, 64, MS_DEF_PROV);
			provType = PROV_RSA_FULL;
			break;
		case 1:
			algorithm = CALG_SHA1;
			strcpy_s(provider, 64, MS_DEF_PROV);
			provType = PROV_RSA_FULL;
			break;

		case 2:
			algorithm = CALG_SHA_256;
			strcpy_s(provider, 64, MS_ENH_RSA_AES_PROV);
			provType = PROV_RSA_AES;
			break;

		case 3:
			algorithm = CALG_SHA_384;
			strcpy_s(provider, 64, MS_ENH_RSA_AES_PROV);
			provType = PROV_RSA_AES;
			break;

		case 4:
			algorithm = CALG_SHA_512;
			strcpy_s(provider, 64, MS_ENH_RSA_AES_PROV);
			provType = PROV_RSA_AES;
			break;

		default:
			__leave;

		}

		// Get security provider
		if (!(CryptAcquireContext(&hProv, myContainer, provider, provType, CRYPT_NEWKEYSET))){
			error = GetLastError();
			if (error == 2148073487){
				if (!(CryptAcquireContext(&hProv, myContainer, provider, provType, 0))){
					__leave;
				}
			}
			else {
				__leave;
			}
		}

		// Create hash object
		if (!(CryptCreateHash(hProv, algorithm, 0, 0, &hHash))){
			__leave;
		}

		// Hash the password
		if (!(CryptHashData(hHash, lpInput, dwSize, 0))){
			__leave;
		}

		// Get the size of the hash
		dwCount = sizeof(DWORD);
		if (!(CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *)&dwDataSize, &dwCount, 0))){
			__leave;
		}

		// Allocate the buffer
		if (!(pbData = (BYTE *)malloc(dwDataSize))){
			__leave;
		}

		// Get the hash value
		if (!(CryptGetHashParam(hHash, HP_HASHVAL, pbData, &dwDataSize, 0))){
			__leave;
		}

		dwOutSize = 2 * dwDataSize + 1;
		lpOutput = (LPSTR)malloc(dwOutSize);
		pOutput = lpOutput;
		for (int i = 0; i < dwDataSize; i++){
			pOutput += sprintf(pOutput, "%02X", pbData[i]);
		}

		returnCode = ERROR_SUCCESS;
	}
	__finally {
		if (hHash) {
			CryptDestroyHash(hHash);
			hHash = 0;
		}

		if (hProv){
			CryptReleaseContext(hProv, 0);
			hProv = 0;
		}

		if (lpInput){
			free(lpInput);
			lpInput = NULL;
		}

		if (lpOutput){
			PA_SetTextParameter(params, 3, lpOutput, dwOutSize);
			free(lpOutput);
			lpOutput = NULL;
		}

		if (pbData){
			free(pbData);
			pbData = NULL;
		}

		PA_ReturnLong(params, returnCode);

	}
}

//  FUNCTION: textEncryption(PA_PluginParameters params, BOOL bDecrypt)
//
//  PURPOSE:	Encrypts/Decrypts a message in AES
//
//  COMMENTS:	Rewrote with updated practices and merged decrypt/encrypt into one method
//
//	DATE:		WJF 10/29/15 Win-4 
void textEncryption(PA_PluginParameters params, BOOL bDecrypt)
{
	HCRYPTPROV	hProv = 0;
	HCRYPTHASH	hHash = 0;
	HCRYPTKEY	hKey = 0;
	PBYTE		pbBuffer;
	DWORD		dwSize = 0;
	BYTE		*pbMessage = 0L;
	BYTE		pbPass[33] = "0";
	DWORD		dwPassLength = 0;
	DWORD		BUFFER_SIZE = 0;
	BYTE		IV[17] = "0";
	DWORD		dwIVLength;
	BYTE		tempIV[17] = "0";
	DWORD		error = 0;
	LPCSTR		myContainer = "MyContainer";

	__try{

		dwSize = PA_GetTextParameter(params, 1, pbMessage);
		
		if (!(pbMessage = (BYTE *)malloc(dwSize+1))){
			__leave;
		}

		dwSize = PA_GetTextParameter(params, 1, pbMessage);

		dwPassLength = PA_GetTextParameter(params, 2, pbPass);

		if (dwPassLength > 32) {
			__leave;
		}

		dwIVLength = PA_GetTextParameter(params, 3, tempIV);

		for (int i = 0; i < 16; i++){
			if (i <= dwIVLength){
				if (tempIV[i] == '\0'){
					IV[i] = '0';
				}
				else {
					IV[i] = tempIV[i];
				}
			}
			else {
				IV[i] = '0';
			}
		}

		// Clean decryption input
		if (bDecrypt){
			for (int i = 0; i < strlen(pbMessage); i++){
				if (pbMessage[i] <= 32) {
					memmove(&pbMessage[i], &pbMessage[i + 1], strlen(pbMessage) - i);
					dwSize--;
					i--;
				}
			}
		}

		// Get security provider
		if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))){
			error = GetLastError();
			if (error == 2148073487){
				if (!(CryptAcquireContext(&hProv, myContainer, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))){
					__leave;
				}
			}
			else {
				__leave;
			}
		}

		// Create hash object
		if (!(CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))){
			__leave;
		}

		// Hash the password
		if (!(CryptHashData(hHash, pbPass, dwPassLength, 0))){
			__leave;
		}

		// Derive the key from the hashed password
		if (!(CryptDeriveKey(hProv, CALG_AES_256, hHash, CRYPT_NO_SALT, &hKey))){
			__leave;
		}

		// Destroy the hash object
		if (!(CryptDestroyHash(hHash))){
			__leave;
		}
		else {
			hHash = 0;
		}

		if (!(CryptSetKeyParam(hKey, KP_IV, &IV, 0))){
			__leave;
		}

		if (bDecrypt){
			BUFFER_SIZE = dwSize + 1;
		}
		else {
			BUFFER_SIZE = ((dwSize + AES_BLOCK_SIZE) / (AES_BLOCK_SIZE))*AES_BLOCK_SIZE;
		}

		pbBuffer = (BYTE *)malloc(BUFFER_SIZE); // Allocate to AES block size

		memcpy_s(pbBuffer, BUFFER_SIZE, pbMessage, dwSize);

		if (bDecrypt){
			pbBuffer = base64_decode(pbBuffer, dwSize, &dwSize); // Decode from base64
			// Decrypt the message
			if (!(CryptDecrypt(hKey, 0, TRUE, 0, pbBuffer, &dwSize))){
				__leave;
			}
		}
		else {
			// Encrypt the message
			if (!(CryptEncrypt(hKey, 0, TRUE, 0, pbBuffer, &dwSize, BUFFER_SIZE))) {
				__leave;
			}
		}

		if (!bDecrypt){
			pbBuffer = base64_encode(pbBuffer, dwSize, &dwSize); // Encode to Base64
		}
	}
	__finally {
		if (hKey) {
			CryptDestroyKey(hKey);
			hKey = 0;
		}

		if (hHash) {
			CryptDestroyHash(hHash);
			hHash = 0;
		}
		if (hProv){ 
			CryptReleaseContext(hProv, 0);
			hProv = 0;
		}

		if (pbBuffer){
			PA_ReturnText(params, pbBuffer, dwSize);
			free(pbBuffer);
			pbBuffer = NULL;
		}

		if (pbMessage){
			free(pbMessage);
			pbMessage = NULL;
		}
	}
}